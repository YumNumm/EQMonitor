// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'tsunami.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

_TsunamiV1Base _$TsunamiV1BaseFromJson(Map<String, dynamic> json) {
  return __TsunamiV1Base.fromJson(json);
}

/// @nodoc
mixin _$TsunamiV1Base {
  int get eventId => throw _privateConstructorUsedError;
  String? get headline => throw _privateConstructorUsedError;
  int get id => throw _privateConstructorUsedError;
  String get infoType => throw _privateConstructorUsedError;
  DateTime get pressAt => throw _privateConstructorUsedError;
  DateTime get reportAt => throw _privateConstructorUsedError;
  int? get serialNo => throw _privateConstructorUsedError;
  String get status => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  DateTime? get validAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$TsunamiV1BaseCopyWith<_TsunamiV1Base> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$TsunamiV1BaseCopyWith<$Res> {
  factory _$TsunamiV1BaseCopyWith(
          _TsunamiV1Base value, $Res Function(_TsunamiV1Base) then) =
      __$TsunamiV1BaseCopyWithImpl<$Res, _TsunamiV1Base>;
  @useResult
  $Res call(
      {int eventId,
      String? headline,
      int id,
      String infoType,
      DateTime pressAt,
      DateTime reportAt,
      int? serialNo,
      String status,
      String type,
      DateTime? validAt});
}

/// @nodoc
class __$TsunamiV1BaseCopyWithImpl<$Res, $Val extends _TsunamiV1Base>
    implements _$TsunamiV1BaseCopyWith<$Res> {
  __$TsunamiV1BaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? eventId = null,
    Object? headline = freezed,
    Object? id = null,
    Object? infoType = null,
    Object? pressAt = null,
    Object? reportAt = null,
    Object? serialNo = freezed,
    Object? status = null,
    Object? type = null,
    Object? validAt = freezed,
  }) {
    return _then(_value.copyWith(
      eventId: null == eventId
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as int,
      headline: freezed == headline
          ? _value.headline
          : headline // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      infoType: null == infoType
          ? _value.infoType
          : infoType // ignore: cast_nullable_to_non_nullable
              as String,
      pressAt: null == pressAt
          ? _value.pressAt
          : pressAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      reportAt: null == reportAt
          ? _value.reportAt
          : reportAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      serialNo: freezed == serialNo
          ? _value.serialNo
          : serialNo // ignore: cast_nullable_to_non_nullable
              as int?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      validAt: freezed == validAt
          ? _value.validAt
          : validAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TsunamiV1BaseImplCopyWith<$Res>
    implements _$TsunamiV1BaseCopyWith<$Res> {
  factory _$$_TsunamiV1BaseImplCopyWith(_$_TsunamiV1BaseImpl value,
          $Res Function(_$_TsunamiV1BaseImpl) then) =
      __$$_TsunamiV1BaseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int eventId,
      String? headline,
      int id,
      String infoType,
      DateTime pressAt,
      DateTime reportAt,
      int? serialNo,
      String status,
      String type,
      DateTime? validAt});
}

/// @nodoc
class __$$_TsunamiV1BaseImplCopyWithImpl<$Res>
    extends __$TsunamiV1BaseCopyWithImpl<$Res, _$_TsunamiV1BaseImpl>
    implements _$$_TsunamiV1BaseImplCopyWith<$Res> {
  __$$_TsunamiV1BaseImplCopyWithImpl(
      _$_TsunamiV1BaseImpl _value, $Res Function(_$_TsunamiV1BaseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? eventId = null,
    Object? headline = freezed,
    Object? id = null,
    Object? infoType = null,
    Object? pressAt = null,
    Object? reportAt = null,
    Object? serialNo = freezed,
    Object? status = null,
    Object? type = null,
    Object? validAt = freezed,
  }) {
    return _then(_$_TsunamiV1BaseImpl(
      eventId: null == eventId
          ? _value.eventId
          : eventId // ignore: cast_nullable_to_non_nullable
              as int,
      headline: freezed == headline
          ? _value.headline
          : headline // ignore: cast_nullable_to_non_nullable
              as String?,
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
      infoType: null == infoType
          ? _value.infoType
          : infoType // ignore: cast_nullable_to_non_nullable
              as String,
      pressAt: null == pressAt
          ? _value.pressAt
          : pressAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      reportAt: null == reportAt
          ? _value.reportAt
          : reportAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      serialNo: freezed == serialNo
          ? _value.serialNo
          : serialNo // ignore: cast_nullable_to_non_nullable
              as int?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      validAt: freezed == validAt
          ? _value.validAt
          : validAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TsunamiV1BaseImpl implements __TsunamiV1Base {
  const _$_TsunamiV1BaseImpl(
      {required this.eventId,
      required this.headline,
      required this.id,
      required this.infoType,
      required this.pressAt,
      required this.reportAt,
      required this.serialNo,
      required this.status,
      required this.type,
      required this.validAt});

  factory _$_TsunamiV1BaseImpl.fromJson(Map<String, dynamic> json) =>
      _$$_TsunamiV1BaseImplFromJson(json);

  @override
  final int eventId;
  @override
  final String? headline;
  @override
  final int id;
  @override
  final String infoType;
  @override
  final DateTime pressAt;
  @override
  final DateTime reportAt;
  @override
  final int? serialNo;
  @override
  final String status;
  @override
  final String type;
  @override
  final DateTime? validAt;

  @override
  String toString() {
    return '_TsunamiV1Base(eventId: $eventId, headline: $headline, id: $id, infoType: $infoType, pressAt: $pressAt, reportAt: $reportAt, serialNo: $serialNo, status: $status, type: $type, validAt: $validAt)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TsunamiV1BaseImpl &&
            (identical(other.eventId, eventId) || other.eventId == eventId) &&
            (identical(other.headline, headline) ||
                other.headline == headline) &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.infoType, infoType) ||
                other.infoType == infoType) &&
            (identical(other.pressAt, pressAt) || other.pressAt == pressAt) &&
            (identical(other.reportAt, reportAt) ||
                other.reportAt == reportAt) &&
            (identical(other.serialNo, serialNo) ||
                other.serialNo == serialNo) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.validAt, validAt) || other.validAt == validAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, eventId, headline, id, infoType,
      pressAt, reportAt, serialNo, status, type, validAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TsunamiV1BaseImplCopyWith<_$_TsunamiV1BaseImpl> get copyWith =>
      __$$_TsunamiV1BaseImplCopyWithImpl<_$_TsunamiV1BaseImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TsunamiV1BaseImplToJson(
      this,
    );
  }
}

abstract class __TsunamiV1Base implements _TsunamiV1Base {
  const factory __TsunamiV1Base(
      {required final int eventId,
      required final String? headline,
      required final int id,
      required final String infoType,
      required final DateTime pressAt,
      required final DateTime reportAt,
      required final int? serialNo,
      required final String status,
      required final String type,
      required final DateTime? validAt}) = _$_TsunamiV1BaseImpl;

  factory __TsunamiV1Base.fromJson(Map<String, dynamic> json) =
      _$_TsunamiV1BaseImpl.fromJson;

  @override
  int get eventId;
  @override
  String? get headline;
  @override
  int get id;
  @override
  String get infoType;
  @override
  DateTime get pressAt;
  @override
  DateTime get reportAt;
  @override
  int? get serialNo;
  @override
  String get status;
  @override
  String get type;
  @override
  DateTime? get validAt;
  @override
  @JsonKey(ignore: true)
  _$$_TsunamiV1BaseImplCopyWith<_$_TsunamiV1BaseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Comment _$CommentFromJson(Map<String, dynamic> json) {
  return _Comment.fromJson(json);
}

/// @nodoc
mixin _$Comment {
  String? get free => throw _privateConstructorUsedError;
  CommentWarning? get warning => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CommentCopyWith<Comment> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentCopyWith<$Res> {
  factory $CommentCopyWith(Comment value, $Res Function(Comment) then) =
      _$CommentCopyWithImpl<$Res, Comment>;
  @useResult
  $Res call({String? free, CommentWarning? warning});

  $CommentWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class _$CommentCopyWithImpl<$Res, $Val extends Comment>
    implements $CommentCopyWith<$Res> {
  _$CommentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? free = freezed,
    Object? warning = freezed,
  }) {
    return _then(_value.copyWith(
      free: freezed == free
          ? _value.free
          : free // ignore: cast_nullable_to_non_nullable
              as String?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as CommentWarning?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CommentWarningCopyWith<$Res>? get warning {
    if (_value.warning == null) {
      return null;
    }

    return $CommentWarningCopyWith<$Res>(_value.warning!, (value) {
      return _then(_value.copyWith(warning: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CommentImplCopyWith<$Res> implements $CommentCopyWith<$Res> {
  factory _$$CommentImplCopyWith(
          _$CommentImpl value, $Res Function(_$CommentImpl) then) =
      __$$CommentImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? free, CommentWarning? warning});

  @override
  $CommentWarningCopyWith<$Res>? get warning;
}

/// @nodoc
class __$$CommentImplCopyWithImpl<$Res>
    extends _$CommentCopyWithImpl<$Res, _$CommentImpl>
    implements _$$CommentImplCopyWith<$Res> {
  __$$CommentImplCopyWithImpl(
      _$CommentImpl _value, $Res Function(_$CommentImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? free = freezed,
    Object? warning = freezed,
  }) {
    return _then(_$CommentImpl(
      free: freezed == free
          ? _value.free
          : free // ignore: cast_nullable_to_non_nullable
              as String?,
      warning: freezed == warning
          ? _value.warning
          : warning // ignore: cast_nullable_to_non_nullable
              as CommentWarning?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CommentImpl implements _Comment {
  const _$CommentImpl({required this.free, required this.warning});

  factory _$CommentImpl.fromJson(Map<String, dynamic> json) =>
      _$$CommentImplFromJson(json);

  @override
  final String? free;
  @override
  final CommentWarning? warning;

  @override
  String toString() {
    return 'Comment(free: $free, warning: $warning)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentImpl &&
            (identical(other.free, free) || other.free == free) &&
            (identical(other.warning, warning) || other.warning == warning));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, free, warning);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentImplCopyWith<_$CommentImpl> get copyWith =>
      __$$CommentImplCopyWithImpl<_$CommentImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CommentImplToJson(
      this,
    );
  }
}

abstract class _Comment implements Comment {
  const factory _Comment(
      {required final String? free,
      required final CommentWarning? warning}) = _$CommentImpl;

  factory _Comment.fromJson(Map<String, dynamic> json) = _$CommentImpl.fromJson;

  @override
  String? get free;
  @override
  CommentWarning? get warning;
  @override
  @JsonKey(ignore: true)
  _$$CommentImplCopyWith<_$CommentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CommentWarning _$CommentWarningFromJson(Map<String, dynamic> json) {
  return _CommentWarning.fromJson(json);
}

/// @nodoc
mixin _$CommentWarning {
  String get text => throw _privateConstructorUsedError;
  List<String> get codes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CommentWarningCopyWith<CommentWarning> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentWarningCopyWith<$Res> {
  factory $CommentWarningCopyWith(
          CommentWarning value, $Res Function(CommentWarning) then) =
      _$CommentWarningCopyWithImpl<$Res, CommentWarning>;
  @useResult
  $Res call({String text, List<String> codes});
}

/// @nodoc
class _$CommentWarningCopyWithImpl<$Res, $Val extends CommentWarning>
    implements $CommentWarningCopyWith<$Res> {
  _$CommentWarningCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? codes = null,
  }) {
    return _then(_value.copyWith(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      codes: null == codes
          ? _value.codes
          : codes // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CommentWarningImplCopyWith<$Res>
    implements $CommentWarningCopyWith<$Res> {
  factory _$$CommentWarningImplCopyWith(_$CommentWarningImpl value,
          $Res Function(_$CommentWarningImpl) then) =
      __$$CommentWarningImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String text, List<String> codes});
}

/// @nodoc
class __$$CommentWarningImplCopyWithImpl<$Res>
    extends _$CommentWarningCopyWithImpl<$Res, _$CommentWarningImpl>
    implements _$$CommentWarningImplCopyWith<$Res> {
  __$$CommentWarningImplCopyWithImpl(
      _$CommentWarningImpl _value, $Res Function(_$CommentWarningImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? codes = null,
  }) {
    return _then(_$CommentWarningImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      codes: null == codes
          ? _value._codes
          : codes // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CommentWarningImpl implements _CommentWarning {
  const _$CommentWarningImpl(
      {required this.text, required final List<String> codes})
      : _codes = codes;

  factory _$CommentWarningImpl.fromJson(Map<String, dynamic> json) =>
      _$$CommentWarningImplFromJson(json);

  @override
  final String text;
  final List<String> _codes;
  @override
  List<String> get codes {
    if (_codes is EqualUnmodifiableListView) return _codes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_codes);
  }

  @override
  String toString() {
    return 'CommentWarning(text: $text, codes: $codes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CommentWarningImpl &&
            (identical(other.text, text) || other.text == text) &&
            const DeepCollectionEquality().equals(other._codes, _codes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, text, const DeepCollectionEquality().hash(_codes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CommentWarningImplCopyWith<_$CommentWarningImpl> get copyWith =>
      __$$CommentWarningImplCopyWithImpl<_$CommentWarningImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CommentWarningImplToJson(
      this,
    );
  }
}

abstract class _CommentWarning implements CommentWarning {
  const factory _CommentWarning(
      {required final String text,
      required final List<String> codes}) = _$CommentWarningImpl;

  factory _CommentWarning.fromJson(Map<String, dynamic> json) =
      _$CommentWarningImpl.fromJson;

  @override
  String get text;
  @override
  List<String> get codes;
  @override
  @JsonKey(ignore: true)
  _$$CommentWarningImplCopyWith<_$CommentWarningImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CancelBody _$CancelBodyFromJson(Map<String, dynamic> json) {
  return _CancelBody.fromJson(json);
}

/// @nodoc
mixin _$CancelBody {
  String get text => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CancelBodyCopyWith<CancelBody> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CancelBodyCopyWith<$Res> {
  factory $CancelBodyCopyWith(
          CancelBody value, $Res Function(CancelBody) then) =
      _$CancelBodyCopyWithImpl<$Res, CancelBody>;
  @useResult
  $Res call({String text});
}

/// @nodoc
class _$CancelBodyCopyWithImpl<$Res, $Val extends CancelBody>
    implements $CancelBodyCopyWith<$Res> {
  _$CancelBodyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
  }) {
    return _then(_value.copyWith(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CancelBodyImplCopyWith<$Res>
    implements $CancelBodyCopyWith<$Res> {
  factory _$$CancelBodyImplCopyWith(
          _$CancelBodyImpl value, $Res Function(_$CancelBodyImpl) then) =
      __$$CancelBodyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String text});
}

/// @nodoc
class __$$CancelBodyImplCopyWithImpl<$Res>
    extends _$CancelBodyCopyWithImpl<$Res, _$CancelBodyImpl>
    implements _$$CancelBodyImplCopyWith<$Res> {
  __$$CancelBodyImplCopyWithImpl(
      _$CancelBodyImpl _value, $Res Function(_$CancelBodyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
  }) {
    return _then(_$CancelBodyImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CancelBodyImpl implements _CancelBody {
  const _$CancelBodyImpl({required this.text});

  factory _$CancelBodyImpl.fromJson(Map<String, dynamic> json) =>
      _$$CancelBodyImplFromJson(json);

  @override
  final String text;

  @override
  String toString() {
    return 'CancelBody(text: $text)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CancelBodyImpl &&
            (identical(other.text, text) || other.text == text));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, text);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CancelBodyImplCopyWith<_$CancelBodyImpl> get copyWith =>
      __$$CancelBodyImplCopyWithImpl<_$CancelBodyImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CancelBodyImplToJson(
      this,
    );
  }
}

abstract class _CancelBody implements CancelBody {
  const factory _CancelBody({required final String text}) = _$CancelBodyImpl;

  factory _CancelBody.fromJson(Map<String, dynamic> json) =
      _$CancelBodyImpl.fromJson;

  @override
  String get text;
  @override
  @JsonKey(ignore: true)
  _$$CancelBodyImplCopyWith<_$CancelBodyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PublicBodyVTSE41Tsunami _$PublicBodyVTSE41TsunamiFromJson(
    Map<String, dynamic> json) {
  return _PublicBodyVTSE41Tsunami.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE41Tsunami {
  List<TsunamiForecast> get forecasts => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE41TsunamiCopyWith<PublicBodyVTSE41Tsunami> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE41TsunamiCopyWith<$Res> {
  factory $PublicBodyVTSE41TsunamiCopyWith(PublicBodyVTSE41Tsunami value,
          $Res Function(PublicBodyVTSE41Tsunami) then) =
      _$PublicBodyVTSE41TsunamiCopyWithImpl<$Res, PublicBodyVTSE41Tsunami>;
  @useResult
  $Res call({List<TsunamiForecast> forecasts});
}

/// @nodoc
class _$PublicBodyVTSE41TsunamiCopyWithImpl<$Res,
        $Val extends PublicBodyVTSE41Tsunami>
    implements $PublicBodyVTSE41TsunamiCopyWith<$Res> {
  _$PublicBodyVTSE41TsunamiCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? forecasts = null,
  }) {
    return _then(_value.copyWith(
      forecasts: null == forecasts
          ? _value.forecasts
          : forecasts // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecast>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE41TsunamiImplCopyWith<$Res>
    implements $PublicBodyVTSE41TsunamiCopyWith<$Res> {
  factory _$$PublicBodyVTSE41TsunamiImplCopyWith(
          _$PublicBodyVTSE41TsunamiImpl value,
          $Res Function(_$PublicBodyVTSE41TsunamiImpl) then) =
      __$$PublicBodyVTSE41TsunamiImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<TsunamiForecast> forecasts});
}

/// @nodoc
class __$$PublicBodyVTSE41TsunamiImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE41TsunamiCopyWithImpl<$Res,
        _$PublicBodyVTSE41TsunamiImpl>
    implements _$$PublicBodyVTSE41TsunamiImplCopyWith<$Res> {
  __$$PublicBodyVTSE41TsunamiImplCopyWithImpl(
      _$PublicBodyVTSE41TsunamiImpl _value,
      $Res Function(_$PublicBodyVTSE41TsunamiImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? forecasts = null,
  }) {
    return _then(_$PublicBodyVTSE41TsunamiImpl(
      forecasts: null == forecasts
          ? _value._forecasts
          : forecasts // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecast>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE41TsunamiImpl implements _PublicBodyVTSE41Tsunami {
  const _$PublicBodyVTSE41TsunamiImpl(
      {required final List<TsunamiForecast> forecasts})
      : _forecasts = forecasts;

  factory _$PublicBodyVTSE41TsunamiImpl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE41TsunamiImplFromJson(json);

  final List<TsunamiForecast> _forecasts;
  @override
  List<TsunamiForecast> get forecasts {
    if (_forecasts is EqualUnmodifiableListView) return _forecasts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_forecasts);
  }

  @override
  String toString() {
    return 'PublicBodyVTSE41Tsunami(forecasts: $forecasts)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE41TsunamiImpl &&
            const DeepCollectionEquality()
                .equals(other._forecasts, _forecasts));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_forecasts));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE41TsunamiImplCopyWith<_$PublicBodyVTSE41TsunamiImpl>
      get copyWith => __$$PublicBodyVTSE41TsunamiImplCopyWithImpl<
          _$PublicBodyVTSE41TsunamiImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE41TsunamiImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE41Tsunami implements PublicBodyVTSE41Tsunami {
  const factory _PublicBodyVTSE41Tsunami(
          {required final List<TsunamiForecast> forecasts}) =
      _$PublicBodyVTSE41TsunamiImpl;

  factory _PublicBodyVTSE41Tsunami.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE41TsunamiImpl.fromJson;

  @override
  List<TsunamiForecast> get forecasts;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE41TsunamiImplCopyWith<_$PublicBodyVTSE41TsunamiImpl>
      get copyWith => throw _privateConstructorUsedError;
}

PublicBodyVTSE51Tsunami _$PublicBodyVTSE51TsunamiFromJson(
    Map<String, dynamic> json) {
  return _PublicBodyVTSE51Tsunami.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE51Tsunami {
  List<TsunamiForecast> get forecasts => throw _privateConstructorUsedError;
  List<TsunamiObservation>? get observations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE51TsunamiCopyWith<PublicBodyVTSE51Tsunami> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE51TsunamiCopyWith<$Res> {
  factory $PublicBodyVTSE51TsunamiCopyWith(PublicBodyVTSE51Tsunami value,
          $Res Function(PublicBodyVTSE51Tsunami) then) =
      _$PublicBodyVTSE51TsunamiCopyWithImpl<$Res, PublicBodyVTSE51Tsunami>;
  @useResult
  $Res call(
      {List<TsunamiForecast> forecasts,
      List<TsunamiObservation>? observations});
}

/// @nodoc
class _$PublicBodyVTSE51TsunamiCopyWithImpl<$Res,
        $Val extends PublicBodyVTSE51Tsunami>
    implements $PublicBodyVTSE51TsunamiCopyWith<$Res> {
  _$PublicBodyVTSE51TsunamiCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? forecasts = null,
    Object? observations = freezed,
  }) {
    return _then(_value.copyWith(
      forecasts: null == forecasts
          ? _value.forecasts
          : forecasts // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecast>,
      observations: freezed == observations
          ? _value.observations
          : observations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservation>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE51TsunamiImplCopyWith<$Res>
    implements $PublicBodyVTSE51TsunamiCopyWith<$Res> {
  factory _$$PublicBodyVTSE51TsunamiImplCopyWith(
          _$PublicBodyVTSE51TsunamiImpl value,
          $Res Function(_$PublicBodyVTSE51TsunamiImpl) then) =
      __$$PublicBodyVTSE51TsunamiImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TsunamiForecast> forecasts,
      List<TsunamiObservation>? observations});
}

/// @nodoc
class __$$PublicBodyVTSE51TsunamiImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE51TsunamiCopyWithImpl<$Res,
        _$PublicBodyVTSE51TsunamiImpl>
    implements _$$PublicBodyVTSE51TsunamiImplCopyWith<$Res> {
  __$$PublicBodyVTSE51TsunamiImplCopyWithImpl(
      _$PublicBodyVTSE51TsunamiImpl _value,
      $Res Function(_$PublicBodyVTSE51TsunamiImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? forecasts = null,
    Object? observations = freezed,
  }) {
    return _then(_$PublicBodyVTSE51TsunamiImpl(
      forecasts: null == forecasts
          ? _value._forecasts
          : forecasts // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecast>,
      observations: freezed == observations
          ? _value._observations
          : observations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservation>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE51TsunamiImpl implements _PublicBodyVTSE51Tsunami {
  const _$PublicBodyVTSE51TsunamiImpl(
      {required final List<TsunamiForecast> forecasts,
      required final List<TsunamiObservation>? observations})
      : _forecasts = forecasts,
        _observations = observations;

  factory _$PublicBodyVTSE51TsunamiImpl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE51TsunamiImplFromJson(json);

  final List<TsunamiForecast> _forecasts;
  @override
  List<TsunamiForecast> get forecasts {
    if (_forecasts is EqualUnmodifiableListView) return _forecasts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_forecasts);
  }

  final List<TsunamiObservation>? _observations;
  @override
  List<TsunamiObservation>? get observations {
    final value = _observations;
    if (value == null) return null;
    if (_observations is EqualUnmodifiableListView) return _observations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'PublicBodyVTSE51Tsunami(forecasts: $forecasts, observations: $observations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE51TsunamiImpl &&
            const DeepCollectionEquality()
                .equals(other._forecasts, _forecasts) &&
            const DeepCollectionEquality()
                .equals(other._observations, _observations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_forecasts),
      const DeepCollectionEquality().hash(_observations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE51TsunamiImplCopyWith<_$PublicBodyVTSE51TsunamiImpl>
      get copyWith => __$$PublicBodyVTSE51TsunamiImplCopyWithImpl<
          _$PublicBodyVTSE51TsunamiImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE51TsunamiImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE51Tsunami implements PublicBodyVTSE51Tsunami {
  const factory _PublicBodyVTSE51Tsunami(
          {required final List<TsunamiForecast> forecasts,
          required final List<TsunamiObservation>? observations}) =
      _$PublicBodyVTSE51TsunamiImpl;

  factory _PublicBodyVTSE51Tsunami.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE51TsunamiImpl.fromJson;

  @override
  List<TsunamiForecast> get forecasts;
  @override
  List<TsunamiObservation>? get observations;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE51TsunamiImplCopyWith<_$PublicBodyVTSE51TsunamiImpl>
      get copyWith => throw _privateConstructorUsedError;
}

PublicBodyVTSE52Tsunami _$PublicBodyVTSE52TsunamiFromJson(
    Map<String, dynamic> json) {
  return _PublicBodyVTSE52Tsunami.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE52Tsunami {
  List<TsunamiObservation>? get observations =>
      throw _privateConstructorUsedError;
  List<TsunamiEstimation> get estimations => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE52TsunamiCopyWith<PublicBodyVTSE52Tsunami> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE52TsunamiCopyWith<$Res> {
  factory $PublicBodyVTSE52TsunamiCopyWith(PublicBodyVTSE52Tsunami value,
          $Res Function(PublicBodyVTSE52Tsunami) then) =
      _$PublicBodyVTSE52TsunamiCopyWithImpl<$Res, PublicBodyVTSE52Tsunami>;
  @useResult
  $Res call(
      {List<TsunamiObservation>? observations,
      List<TsunamiEstimation> estimations});
}

/// @nodoc
class _$PublicBodyVTSE52TsunamiCopyWithImpl<$Res,
        $Val extends PublicBodyVTSE52Tsunami>
    implements $PublicBodyVTSE52TsunamiCopyWith<$Res> {
  _$PublicBodyVTSE52TsunamiCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? observations = freezed,
    Object? estimations = null,
  }) {
    return _then(_value.copyWith(
      observations: freezed == observations
          ? _value.observations
          : observations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservation>?,
      estimations: null == estimations
          ? _value.estimations
          : estimations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiEstimation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE52TsunamiImplCopyWith<$Res>
    implements $PublicBodyVTSE52TsunamiCopyWith<$Res> {
  factory _$$PublicBodyVTSE52TsunamiImplCopyWith(
          _$PublicBodyVTSE52TsunamiImpl value,
          $Res Function(_$PublicBodyVTSE52TsunamiImpl) then) =
      __$$PublicBodyVTSE52TsunamiImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TsunamiObservation>? observations,
      List<TsunamiEstimation> estimations});
}

/// @nodoc
class __$$PublicBodyVTSE52TsunamiImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE52TsunamiCopyWithImpl<$Res,
        _$PublicBodyVTSE52TsunamiImpl>
    implements _$$PublicBodyVTSE52TsunamiImplCopyWith<$Res> {
  __$$PublicBodyVTSE52TsunamiImplCopyWithImpl(
      _$PublicBodyVTSE52TsunamiImpl _value,
      $Res Function(_$PublicBodyVTSE52TsunamiImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? observations = freezed,
    Object? estimations = null,
  }) {
    return _then(_$PublicBodyVTSE52TsunamiImpl(
      observations: freezed == observations
          ? _value._observations
          : observations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservation>?,
      estimations: null == estimations
          ? _value._estimations
          : estimations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiEstimation>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE52TsunamiImpl implements _PublicBodyVTSE52Tsunami {
  const _$PublicBodyVTSE52TsunamiImpl(
      {required final List<TsunamiObservation>? observations,
      required final List<TsunamiEstimation> estimations})
      : _observations = observations,
        _estimations = estimations;

  factory _$PublicBodyVTSE52TsunamiImpl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE52TsunamiImplFromJson(json);

  final List<TsunamiObservation>? _observations;
  @override
  List<TsunamiObservation>? get observations {
    final value = _observations;
    if (value == null) return null;
    if (_observations is EqualUnmodifiableListView) return _observations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<TsunamiEstimation> _estimations;
  @override
  List<TsunamiEstimation> get estimations {
    if (_estimations is EqualUnmodifiableListView) return _estimations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_estimations);
  }

  @override
  String toString() {
    return 'PublicBodyVTSE52Tsunami(observations: $observations, estimations: $estimations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE52TsunamiImpl &&
            const DeepCollectionEquality()
                .equals(other._observations, _observations) &&
            const DeepCollectionEquality()
                .equals(other._estimations, _estimations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_observations),
      const DeepCollectionEquality().hash(_estimations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE52TsunamiImplCopyWith<_$PublicBodyVTSE52TsunamiImpl>
      get copyWith => __$$PublicBodyVTSE52TsunamiImplCopyWithImpl<
          _$PublicBodyVTSE52TsunamiImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE52TsunamiImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE52Tsunami implements PublicBodyVTSE52Tsunami {
  const factory _PublicBodyVTSE52Tsunami(
          {required final List<TsunamiObservation>? observations,
          required final List<TsunamiEstimation> estimations}) =
      _$PublicBodyVTSE52TsunamiImpl;

  factory _PublicBodyVTSE52Tsunami.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE52TsunamiImpl.fromJson;

  @override
  List<TsunamiObservation>? get observations;
  @override
  List<TsunamiEstimation> get estimations;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE52TsunamiImplCopyWith<_$PublicBodyVTSE52TsunamiImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TsunamiForecast _$TsunamiForecastFromJson(Map<String, dynamic> json) {
  return _TsunamiForecast.fromJson(json);
}

/// @nodoc
mixin _$TsunamiForecast {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get kind => throw _privateConstructorUsedError;
  String get lastKind => throw _privateConstructorUsedError;
  TsunamiForecastFirstHeight? get firstHeight =>
      throw _privateConstructorUsedError;
  TsunamiForecastMaxHeight? get maxHeight => throw _privateConstructorUsedError;
  List<TsunamiForecastStation>? get stations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiForecastCopyWith<TsunamiForecast> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiForecastCopyWith<$Res> {
  factory $TsunamiForecastCopyWith(
          TsunamiForecast value, $Res Function(TsunamiForecast) then) =
      _$TsunamiForecastCopyWithImpl<$Res, TsunamiForecast>;
  @useResult
  $Res call(
      {String code,
      String name,
      String kind,
      String lastKind,
      TsunamiForecastFirstHeight? firstHeight,
      TsunamiForecastMaxHeight? maxHeight,
      List<TsunamiForecastStation>? stations});

  $TsunamiForecastFirstHeightCopyWith<$Res>? get firstHeight;
  $TsunamiForecastMaxHeightCopyWith<$Res>? get maxHeight;
}

/// @nodoc
class _$TsunamiForecastCopyWithImpl<$Res, $Val extends TsunamiForecast>
    implements $TsunamiForecastCopyWith<$Res> {
  _$TsunamiForecastCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? kind = null,
    Object? lastKind = null,
    Object? firstHeight = freezed,
    Object? maxHeight = freezed,
    Object? stations = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String,
      lastKind: null == lastKind
          ? _value.lastKind
          : lastKind // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeight: freezed == firstHeight
          ? _value.firstHeight
          : firstHeight // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeight?,
      maxHeight: freezed == maxHeight
          ? _value.maxHeight
          : maxHeight // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastMaxHeight?,
      stations: freezed == stations
          ? _value.stations
          : stations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecastStation>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TsunamiForecastFirstHeightCopyWith<$Res>? get firstHeight {
    if (_value.firstHeight == null) {
      return null;
    }

    return $TsunamiForecastFirstHeightCopyWith<$Res>(_value.firstHeight!,
        (value) {
      return _then(_value.copyWith(firstHeight: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TsunamiForecastMaxHeightCopyWith<$Res>? get maxHeight {
    if (_value.maxHeight == null) {
      return null;
    }

    return $TsunamiForecastMaxHeightCopyWith<$Res>(_value.maxHeight!, (value) {
      return _then(_value.copyWith(maxHeight: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$TsunamiForecastImplCopyWith<$Res>
    implements $TsunamiForecastCopyWith<$Res> {
  factory _$$TsunamiForecastImplCopyWith(_$TsunamiForecastImpl value,
          $Res Function(_$TsunamiForecastImpl) then) =
      __$$TsunamiForecastImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String name,
      String kind,
      String lastKind,
      TsunamiForecastFirstHeight? firstHeight,
      TsunamiForecastMaxHeight? maxHeight,
      List<TsunamiForecastStation>? stations});

  @override
  $TsunamiForecastFirstHeightCopyWith<$Res>? get firstHeight;
  @override
  $TsunamiForecastMaxHeightCopyWith<$Res>? get maxHeight;
}

/// @nodoc
class __$$TsunamiForecastImplCopyWithImpl<$Res>
    extends _$TsunamiForecastCopyWithImpl<$Res, _$TsunamiForecastImpl>
    implements _$$TsunamiForecastImplCopyWith<$Res> {
  __$$TsunamiForecastImplCopyWithImpl(
      _$TsunamiForecastImpl _value, $Res Function(_$TsunamiForecastImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? kind = null,
    Object? lastKind = null,
    Object? firstHeight = freezed,
    Object? maxHeight = freezed,
    Object? stations = freezed,
  }) {
    return _then(_$TsunamiForecastImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String,
      lastKind: null == lastKind
          ? _value.lastKind
          : lastKind // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeight: freezed == firstHeight
          ? _value.firstHeight
          : firstHeight // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeight?,
      maxHeight: freezed == maxHeight
          ? _value.maxHeight
          : maxHeight // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastMaxHeight?,
      stations: freezed == stations
          ? _value._stations
          : stations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiForecastStation>?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiForecastImpl implements _TsunamiForecast {
  const _$TsunamiForecastImpl(
      {required this.code,
      required this.name,
      required this.kind,
      required this.lastKind,
      required this.firstHeight,
      required this.maxHeight,
      required final List<TsunamiForecastStation>? stations})
      : _stations = stations;

  factory _$TsunamiForecastImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiForecastImplFromJson(json);

  @override
  final String code;
  @override
  final String name;
  @override
  final String kind;
  @override
  final String lastKind;
  @override
  final TsunamiForecastFirstHeight? firstHeight;
  @override
  final TsunamiForecastMaxHeight? maxHeight;
  final List<TsunamiForecastStation>? _stations;
  @override
  List<TsunamiForecastStation>? get stations {
    final value = _stations;
    if (value == null) return null;
    if (_stations is EqualUnmodifiableListView) return _stations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'TsunamiForecast(code: $code, name: $name, kind: $kind, lastKind: $lastKind, firstHeight: $firstHeight, maxHeight: $maxHeight, stations: $stations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiForecastImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.lastKind, lastKind) ||
                other.lastKind == lastKind) &&
            (identical(other.firstHeight, firstHeight) ||
                other.firstHeight == firstHeight) &&
            (identical(other.maxHeight, maxHeight) ||
                other.maxHeight == maxHeight) &&
            const DeepCollectionEquality().equals(other._stations, _stations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, name, kind, lastKind,
      firstHeight, maxHeight, const DeepCollectionEquality().hash(_stations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiForecastImplCopyWith<_$TsunamiForecastImpl> get copyWith =>
      __$$TsunamiForecastImplCopyWithImpl<_$TsunamiForecastImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiForecastImplToJson(
      this,
    );
  }
}

abstract class _TsunamiForecast implements TsunamiForecast {
  const factory _TsunamiForecast(
          {required final String code,
          required final String name,
          required final String kind,
          required final String lastKind,
          required final TsunamiForecastFirstHeight? firstHeight,
          required final TsunamiForecastMaxHeight? maxHeight,
          required final List<TsunamiForecastStation>? stations}) =
      _$TsunamiForecastImpl;

  factory _TsunamiForecast.fromJson(Map<String, dynamic> json) =
      _$TsunamiForecastImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override
  String get kind;
  @override
  String get lastKind;
  @override
  TsunamiForecastFirstHeight? get firstHeight;
  @override
  TsunamiForecastMaxHeight? get maxHeight;
  @override
  List<TsunamiForecastStation>? get stations;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiForecastImplCopyWith<_$TsunamiForecastImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TsunamiForecastFirstHeight _$TsunamiForecastFirstHeightFromJson(
    Map<String, dynamic> json) {
  return _TsunamiForecastFirstHeight.fromJson(json);
}

/// @nodoc
mixin _$TsunamiForecastFirstHeight {
  DateTime? get arrivalTime => throw _privateConstructorUsedError;
  TsunamiForecastFirstHeightCondition? get condition =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiForecastFirstHeightCopyWith<TsunamiForecastFirstHeight>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiForecastFirstHeightCopyWith<$Res> {
  factory $TsunamiForecastFirstHeightCopyWith(TsunamiForecastFirstHeight value,
          $Res Function(TsunamiForecastFirstHeight) then) =
      _$TsunamiForecastFirstHeightCopyWithImpl<$Res,
          TsunamiForecastFirstHeight>;
  @useResult
  $Res call(
      {DateTime? arrivalTime, TsunamiForecastFirstHeightCondition? condition});
}

/// @nodoc
class _$TsunamiForecastFirstHeightCopyWithImpl<$Res,
        $Val extends TsunamiForecastFirstHeight>
    implements $TsunamiForecastFirstHeightCopyWith<$Res> {
  _$TsunamiForecastFirstHeightCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? arrivalTime = freezed,
    Object? condition = freezed,
  }) {
    return _then(_value.copyWith(
      arrivalTime: freezed == arrivalTime
          ? _value.arrivalTime
          : arrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeightCondition?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiForecastFirstHeightImplCopyWith<$Res>
    implements $TsunamiForecastFirstHeightCopyWith<$Res> {
  factory _$$TsunamiForecastFirstHeightImplCopyWith(
          _$TsunamiForecastFirstHeightImpl value,
          $Res Function(_$TsunamiForecastFirstHeightImpl) then) =
      __$$TsunamiForecastFirstHeightImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DateTime? arrivalTime, TsunamiForecastFirstHeightCondition? condition});
}

/// @nodoc
class __$$TsunamiForecastFirstHeightImplCopyWithImpl<$Res>
    extends _$TsunamiForecastFirstHeightCopyWithImpl<$Res,
        _$TsunamiForecastFirstHeightImpl>
    implements _$$TsunamiForecastFirstHeightImplCopyWith<$Res> {
  __$$TsunamiForecastFirstHeightImplCopyWithImpl(
      _$TsunamiForecastFirstHeightImpl _value,
      $Res Function(_$TsunamiForecastFirstHeightImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? arrivalTime = freezed,
    Object? condition = freezed,
  }) {
    return _then(_$TsunamiForecastFirstHeightImpl(
      arrivalTime: freezed == arrivalTime
          ? _value.arrivalTime
          : arrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeightCondition?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiForecastFirstHeightImpl implements _TsunamiForecastFirstHeight {
  const _$TsunamiForecastFirstHeightImpl(
      {required this.arrivalTime, required this.condition});

  factory _$TsunamiForecastFirstHeightImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$TsunamiForecastFirstHeightImplFromJson(json);

  @override
  final DateTime? arrivalTime;
  @override
  final TsunamiForecastFirstHeightCondition? condition;

  @override
  String toString() {
    return 'TsunamiForecastFirstHeight(arrivalTime: $arrivalTime, condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiForecastFirstHeightImpl &&
            (identical(other.arrivalTime, arrivalTime) ||
                other.arrivalTime == arrivalTime) &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, arrivalTime, condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiForecastFirstHeightImplCopyWith<_$TsunamiForecastFirstHeightImpl>
      get copyWith => __$$TsunamiForecastFirstHeightImplCopyWithImpl<
          _$TsunamiForecastFirstHeightImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiForecastFirstHeightImplToJson(
      this,
    );
  }
}

abstract class _TsunamiForecastFirstHeight
    implements TsunamiForecastFirstHeight {
  const factory _TsunamiForecastFirstHeight(
          {required final DateTime? arrivalTime,
          required final TsunamiForecastFirstHeightCondition? condition}) =
      _$TsunamiForecastFirstHeightImpl;

  factory _TsunamiForecastFirstHeight.fromJson(Map<String, dynamic> json) =
      _$TsunamiForecastFirstHeightImpl.fromJson;

  @override
  DateTime? get arrivalTime;
  @override
  TsunamiForecastFirstHeightCondition? get condition;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiForecastFirstHeightImplCopyWith<_$TsunamiForecastFirstHeightImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TsunamiForecastMaxHeight _$TsunamiForecastMaxHeightFromJson(
    Map<String, dynamic> json) {
  return _TsunamiForecastMaxHeight.fromJson(json);
}

/// @nodoc
mixin _$TsunamiForecastMaxHeight {
  /// 
  double? get value => throw _privateConstructorUsedError;
  bool? get isOver => throw _privateConstructorUsedError;

  /// 
  TsunamiMaxHeightCondition? get condition =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiForecastMaxHeightCopyWith<TsunamiForecastMaxHeight> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiForecastMaxHeightCopyWith<$Res> {
  factory $TsunamiForecastMaxHeightCopyWith(TsunamiForecastMaxHeight value,
          $Res Function(TsunamiForecastMaxHeight) then) =
      _$TsunamiForecastMaxHeightCopyWithImpl<$Res, TsunamiForecastMaxHeight>;
  @useResult
  $Res call(
      {double? value, bool? isOver, TsunamiMaxHeightCondition? condition});
}

/// @nodoc
class _$TsunamiForecastMaxHeightCopyWithImpl<$Res,
        $Val extends TsunamiForecastMaxHeight>
    implements $TsunamiForecastMaxHeightCopyWith<$Res> {
  _$TsunamiForecastMaxHeightCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? isOver = freezed,
    Object? condition = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double?,
      isOver: freezed == isOver
          ? _value.isOver
          : isOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiMaxHeightCondition?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiForecastMaxHeightImplCopyWith<$Res>
    implements $TsunamiForecastMaxHeightCopyWith<$Res> {
  factory _$$TsunamiForecastMaxHeightImplCopyWith(
          _$TsunamiForecastMaxHeightImpl value,
          $Res Function(_$TsunamiForecastMaxHeightImpl) then) =
      __$$TsunamiForecastMaxHeightImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? value, bool? isOver, TsunamiMaxHeightCondition? condition});
}

/// @nodoc
class __$$TsunamiForecastMaxHeightImplCopyWithImpl<$Res>
    extends _$TsunamiForecastMaxHeightCopyWithImpl<$Res,
        _$TsunamiForecastMaxHeightImpl>
    implements _$$TsunamiForecastMaxHeightImplCopyWith<$Res> {
  __$$TsunamiForecastMaxHeightImplCopyWithImpl(
      _$TsunamiForecastMaxHeightImpl _value,
      $Res Function(_$TsunamiForecastMaxHeightImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? isOver = freezed,
    Object? condition = freezed,
  }) {
    return _then(_$TsunamiForecastMaxHeightImpl(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double?,
      isOver: freezed == isOver
          ? _value.isOver
          : isOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiMaxHeightCondition?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiForecastMaxHeightImpl implements _TsunamiForecastMaxHeight {
  const _$TsunamiForecastMaxHeightImpl(
      {required this.value, required this.isOver, required this.condition});

  factory _$TsunamiForecastMaxHeightImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiForecastMaxHeightImplFromJson(json);

  /// 
  @override
  final double? value;
  @override
  final bool? isOver;

  /// 
  @override
  final TsunamiMaxHeightCondition? condition;

  @override
  String toString() {
    return 'TsunamiForecastMaxHeight(value: $value, isOver: $isOver, condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiForecastMaxHeightImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.isOver, isOver) || other.isOver == isOver) &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value, isOver, condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiForecastMaxHeightImplCopyWith<_$TsunamiForecastMaxHeightImpl>
      get copyWith => __$$TsunamiForecastMaxHeightImplCopyWithImpl<
          _$TsunamiForecastMaxHeightImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiForecastMaxHeightImplToJson(
      this,
    );
  }
}

abstract class _TsunamiForecastMaxHeight implements TsunamiForecastMaxHeight {
  const factory _TsunamiForecastMaxHeight(
          {required final double? value,
          required final bool? isOver,
          required final TsunamiMaxHeightCondition? condition}) =
      _$TsunamiForecastMaxHeightImpl;

  factory _TsunamiForecastMaxHeight.fromJson(Map<String, dynamic> json) =
      _$TsunamiForecastMaxHeightImpl.fromJson;

  @override

  /// 
  double? get value;
  @override
  bool? get isOver;
  @override

  /// 
  TsunamiMaxHeightCondition? get condition;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiForecastMaxHeightImplCopyWith<_$TsunamiForecastMaxHeightImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TsunamiForecastStation _$TsunamiForecastStationFromJson(
    Map<String, dynamic> json) {
  return _TsunamiForecastStation.fromJson(json);
}

/// @nodoc
mixin _$TsunamiForecastStation {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  DateTime get highTideTime => throw _privateConstructorUsedError;
  DateTime? get firstHeightTime => throw _privateConstructorUsedError;
  TsunamiForecastFirstHeightCondition? get condition =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiForecastStationCopyWith<TsunamiForecastStation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiForecastStationCopyWith<$Res> {
  factory $TsunamiForecastStationCopyWith(TsunamiForecastStation value,
          $Res Function(TsunamiForecastStation) then) =
      _$TsunamiForecastStationCopyWithImpl<$Res, TsunamiForecastStation>;
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime highTideTime,
      DateTime? firstHeightTime,
      TsunamiForecastFirstHeightCondition? condition});
}

/// @nodoc
class _$TsunamiForecastStationCopyWithImpl<$Res,
        $Val extends TsunamiForecastStation>
    implements $TsunamiForecastStationCopyWith<$Res> {
  _$TsunamiForecastStationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? highTideTime = null,
    Object? firstHeightTime = freezed,
    Object? condition = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      highTideTime: null == highTideTime
          ? _value.highTideTime
          : highTideTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      firstHeightTime: freezed == firstHeightTime
          ? _value.firstHeightTime
          : firstHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeightCondition?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiForecastStationImplCopyWith<$Res>
    implements $TsunamiForecastStationCopyWith<$Res> {
  factory _$$TsunamiForecastStationImplCopyWith(
          _$TsunamiForecastStationImpl value,
          $Res Function(_$TsunamiForecastStationImpl) then) =
      __$$TsunamiForecastStationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime highTideTime,
      DateTime? firstHeightTime,
      TsunamiForecastFirstHeightCondition? condition});
}

/// @nodoc
class __$$TsunamiForecastStationImplCopyWithImpl<$Res>
    extends _$TsunamiForecastStationCopyWithImpl<$Res,
        _$TsunamiForecastStationImpl>
    implements _$$TsunamiForecastStationImplCopyWith<$Res> {
  __$$TsunamiForecastStationImplCopyWithImpl(
      _$TsunamiForecastStationImpl _value,
      $Res Function(_$TsunamiForecastStationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? highTideTime = null,
    Object? firstHeightTime = freezed,
    Object? condition = freezed,
  }) {
    return _then(_$TsunamiForecastStationImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      highTideTime: null == highTideTime
          ? _value.highTideTime
          : highTideTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      firstHeightTime: freezed == firstHeightTime
          ? _value.firstHeightTime
          : firstHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiForecastFirstHeightCondition?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiForecastStationImpl implements _TsunamiForecastStation {
  const _$TsunamiForecastStationImpl(
      {required this.code,
      required this.name,
      required this.highTideTime,
      required this.firstHeightTime,
      required this.condition});

  factory _$TsunamiForecastStationImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiForecastStationImplFromJson(json);

  @override
  final String code;
  @override
  final String name;
  @override
  final DateTime highTideTime;
  @override
  final DateTime? firstHeightTime;
  @override
  final TsunamiForecastFirstHeightCondition? condition;

  @override
  String toString() {
    return 'TsunamiForecastStation(code: $code, name: $name, highTideTime: $highTideTime, firstHeightTime: $firstHeightTime, condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiForecastStationImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.highTideTime, highTideTime) ||
                other.highTideTime == highTideTime) &&
            (identical(other.firstHeightTime, firstHeightTime) ||
                other.firstHeightTime == firstHeightTime) &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, code, name, highTideTime, firstHeightTime, condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiForecastStationImplCopyWith<_$TsunamiForecastStationImpl>
      get copyWith => __$$TsunamiForecastStationImplCopyWithImpl<
          _$TsunamiForecastStationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiForecastStationImplToJson(
      this,
    );
  }
}

abstract class _TsunamiForecastStation implements TsunamiForecastStation {
  const factory _TsunamiForecastStation(
          {required final String code,
          required final String name,
          required final DateTime highTideTime,
          required final DateTime? firstHeightTime,
          required final TsunamiForecastFirstHeightCondition? condition}) =
      _$TsunamiForecastStationImpl;

  factory _TsunamiForecastStation.fromJson(Map<String, dynamic> json) =
      _$TsunamiForecastStationImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override
  DateTime get highTideTime;
  @override
  DateTime? get firstHeightTime;
  @override
  TsunamiForecastFirstHeightCondition? get condition;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiForecastStationImplCopyWith<_$TsunamiForecastStationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TsunamiObservation _$TsunamiObservationFromJson(Map<String, dynamic> json) {
  return _TsunamiObservation.fromJson(json);
}

/// @nodoc
mixin _$TsunamiObservation {
  String? get code => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  List<TsunamiObservationStation> get stations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiObservationCopyWith<TsunamiObservation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiObservationCopyWith<$Res> {
  factory $TsunamiObservationCopyWith(
          TsunamiObservation value, $Res Function(TsunamiObservation) then) =
      _$TsunamiObservationCopyWithImpl<$Res, TsunamiObservation>;
  @useResult
  $Res call(
      {String? code, String? name, List<TsunamiObservationStation> stations});
}

/// @nodoc
class _$TsunamiObservationCopyWithImpl<$Res, $Val extends TsunamiObservation>
    implements $TsunamiObservationCopyWith<$Res> {
  _$TsunamiObservationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? name = freezed,
    Object? stations = null,
  }) {
    return _then(_value.copyWith(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      stations: null == stations
          ? _value.stations
          : stations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservationStation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiObservationImplCopyWith<$Res>
    implements $TsunamiObservationCopyWith<$Res> {
  factory _$$TsunamiObservationImplCopyWith(_$TsunamiObservationImpl value,
          $Res Function(_$TsunamiObservationImpl) then) =
      __$$TsunamiObservationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? code, String? name, List<TsunamiObservationStation> stations});
}

/// @nodoc
class __$$TsunamiObservationImplCopyWithImpl<$Res>
    extends _$TsunamiObservationCopyWithImpl<$Res, _$TsunamiObservationImpl>
    implements _$$TsunamiObservationImplCopyWith<$Res> {
  __$$TsunamiObservationImplCopyWithImpl(_$TsunamiObservationImpl _value,
      $Res Function(_$TsunamiObservationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? name = freezed,
    Object? stations = null,
  }) {
    return _then(_$TsunamiObservationImpl(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      stations: null == stations
          ? _value._stations
          : stations // ignore: cast_nullable_to_non_nullable
              as List<TsunamiObservationStation>,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiObservationImpl implements _TsunamiObservation {
  const _$TsunamiObservationImpl(
      {required this.code,
      required this.name,
      required final List<TsunamiObservationStation> stations})
      : _stations = stations;

  factory _$TsunamiObservationImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiObservationImplFromJson(json);

  @override
  final String? code;
  @override
  final String? name;
  final List<TsunamiObservationStation> _stations;
  @override
  List<TsunamiObservationStation> get stations {
    if (_stations is EqualUnmodifiableListView) return _stations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_stations);
  }

  @override
  String toString() {
    return 'TsunamiObservation(code: $code, name: $name, stations: $stations)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiObservationImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality().equals(other._stations, _stations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, code, name, const DeepCollectionEquality().hash(_stations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiObservationImplCopyWith<_$TsunamiObservationImpl> get copyWith =>
      __$$TsunamiObservationImplCopyWithImpl<_$TsunamiObservationImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiObservationImplToJson(
      this,
    );
  }
}

abstract class _TsunamiObservation implements TsunamiObservation {
  const factory _TsunamiObservation(
          {required final String? code,
          required final String? name,
          required final List<TsunamiObservationStation> stations}) =
      _$TsunamiObservationImpl;

  factory _TsunamiObservation.fromJson(Map<String, dynamic> json) =
      _$TsunamiObservationImpl.fromJson;

  @override
  String? get code;
  @override
  String? get name;
  @override
  List<TsunamiObservationStation> get stations;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiObservationImplCopyWith<_$TsunamiObservationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TsunamiObservationStation _$TsunamiObservationStationFromJson(
    Map<String, dynamic> json) {
  return _TsunamiObservationStation.fromJson(json);
}

/// @nodoc
mixin _$TsunamiObservationStation {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  /// null: ``
  DateTime? get firstHeightArrivalTime => throw _privateConstructorUsedError;
  TsunamiObservationStationFirstHeightIntial? get firstHeightInitial =>
      throw _privateConstructorUsedError;
  DateTime? get maxHeightTime => throw _privateConstructorUsedError;
  double? get maxHeightValue => throw _privateConstructorUsedError;
  bool? get maxHeightIsOver => throw _privateConstructorUsedError;

  /// 
  bool? get maxHeightIsRising => throw _privateConstructorUsedError;
  TsunamiObservationStationCondition? get condition =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiObservationStationCopyWith<TsunamiObservationStation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiObservationStationCopyWith<$Res> {
  factory $TsunamiObservationStationCopyWith(TsunamiObservationStation value,
          $Res Function(TsunamiObservationStation) then) =
      _$TsunamiObservationStationCopyWithImpl<$Res, TsunamiObservationStation>;
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime? firstHeightArrivalTime,
      TsunamiObservationStationFirstHeightIntial? firstHeightInitial,
      DateTime? maxHeightTime,
      double? maxHeightValue,
      bool? maxHeightIsOver,
      bool? maxHeightIsRising,
      TsunamiObservationStationCondition? condition});
}

/// @nodoc
class _$TsunamiObservationStationCopyWithImpl<$Res,
        $Val extends TsunamiObservationStation>
    implements $TsunamiObservationStationCopyWith<$Res> {
  _$TsunamiObservationStationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? firstHeightArrivalTime = freezed,
    Object? firstHeightInitial = freezed,
    Object? maxHeightTime = freezed,
    Object? maxHeightValue = freezed,
    Object? maxHeightIsOver = freezed,
    Object? maxHeightIsRising = freezed,
    Object? condition = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeightArrivalTime: freezed == firstHeightArrivalTime
          ? _value.firstHeightArrivalTime
          : firstHeightArrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstHeightInitial: freezed == firstHeightInitial
          ? _value.firstHeightInitial
          : firstHeightInitial // ignore: cast_nullable_to_non_nullable
              as TsunamiObservationStationFirstHeightIntial?,
      maxHeightTime: freezed == maxHeightTime
          ? _value.maxHeightTime
          : maxHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      maxHeightValue: freezed == maxHeightValue
          ? _value.maxHeightValue
          : maxHeightValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxHeightIsOver: freezed == maxHeightIsOver
          ? _value.maxHeightIsOver
          : maxHeightIsOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      maxHeightIsRising: freezed == maxHeightIsRising
          ? _value.maxHeightIsRising
          : maxHeightIsRising // ignore: cast_nullable_to_non_nullable
              as bool?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiObservationStationCondition?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiObservationStationImplCopyWith<$Res>
    implements $TsunamiObservationStationCopyWith<$Res> {
  factory _$$TsunamiObservationStationImplCopyWith(
          _$TsunamiObservationStationImpl value,
          $Res Function(_$TsunamiObservationStationImpl) then) =
      __$$TsunamiObservationStationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime? firstHeightArrivalTime,
      TsunamiObservationStationFirstHeightIntial? firstHeightInitial,
      DateTime? maxHeightTime,
      double? maxHeightValue,
      bool? maxHeightIsOver,
      bool? maxHeightIsRising,
      TsunamiObservationStationCondition? condition});
}

/// @nodoc
class __$$TsunamiObservationStationImplCopyWithImpl<$Res>
    extends _$TsunamiObservationStationCopyWithImpl<$Res,
        _$TsunamiObservationStationImpl>
    implements _$$TsunamiObservationStationImplCopyWith<$Res> {
  __$$TsunamiObservationStationImplCopyWithImpl(
      _$TsunamiObservationStationImpl _value,
      $Res Function(_$TsunamiObservationStationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? firstHeightArrivalTime = freezed,
    Object? firstHeightInitial = freezed,
    Object? maxHeightTime = freezed,
    Object? maxHeightValue = freezed,
    Object? maxHeightIsOver = freezed,
    Object? maxHeightIsRising = freezed,
    Object? condition = freezed,
  }) {
    return _then(_$TsunamiObservationStationImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeightArrivalTime: freezed == firstHeightArrivalTime
          ? _value.firstHeightArrivalTime
          : firstHeightArrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstHeightInitial: freezed == firstHeightInitial
          ? _value.firstHeightInitial
          : firstHeightInitial // ignore: cast_nullable_to_non_nullable
              as TsunamiObservationStationFirstHeightIntial?,
      maxHeightTime: freezed == maxHeightTime
          ? _value.maxHeightTime
          : maxHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      maxHeightValue: freezed == maxHeightValue
          ? _value.maxHeightValue
          : maxHeightValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxHeightIsOver: freezed == maxHeightIsOver
          ? _value.maxHeightIsOver
          : maxHeightIsOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      maxHeightIsRising: freezed == maxHeightIsRising
          ? _value.maxHeightIsRising
          : maxHeightIsRising // ignore: cast_nullable_to_non_nullable
              as bool?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as TsunamiObservationStationCondition?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiObservationStationImpl implements _TsunamiObservationStation {
  const _$TsunamiObservationStationImpl(
      {required this.code,
      required this.name,
      required this.firstHeightArrivalTime,
      required this.firstHeightInitial,
      required this.maxHeightTime,
      required this.maxHeightValue,
      required this.maxHeightIsOver,
      required this.maxHeightIsRising,
      required this.condition});

  factory _$TsunamiObservationStationImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiObservationStationImplFromJson(json);

  @override
  final String code;
  @override
  final String name;

  /// null: ``
  @override
  final DateTime? firstHeightArrivalTime;
  @override
  final TsunamiObservationStationFirstHeightIntial? firstHeightInitial;
  @override
  final DateTime? maxHeightTime;
  @override
  final double? maxHeightValue;
  @override
  final bool? maxHeightIsOver;

  /// 
  @override
  final bool? maxHeightIsRising;
  @override
  final TsunamiObservationStationCondition? condition;

  @override
  String toString() {
    return 'TsunamiObservationStation(code: $code, name: $name, firstHeightArrivalTime: $firstHeightArrivalTime, firstHeightInitial: $firstHeightInitial, maxHeightTime: $maxHeightTime, maxHeightValue: $maxHeightValue, maxHeightIsOver: $maxHeightIsOver, maxHeightIsRising: $maxHeightIsRising, condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiObservationStationImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.firstHeightArrivalTime, firstHeightArrivalTime) ||
                other.firstHeightArrivalTime == firstHeightArrivalTime) &&
            (identical(other.firstHeightInitial, firstHeightInitial) ||
                other.firstHeightInitial == firstHeightInitial) &&
            (identical(other.maxHeightTime, maxHeightTime) ||
                other.maxHeightTime == maxHeightTime) &&
            (identical(other.maxHeightValue, maxHeightValue) ||
                other.maxHeightValue == maxHeightValue) &&
            (identical(other.maxHeightIsOver, maxHeightIsOver) ||
                other.maxHeightIsOver == maxHeightIsOver) &&
            (identical(other.maxHeightIsRising, maxHeightIsRising) ||
                other.maxHeightIsRising == maxHeightIsRising) &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      code,
      name,
      firstHeightArrivalTime,
      firstHeightInitial,
      maxHeightTime,
      maxHeightValue,
      maxHeightIsOver,
      maxHeightIsRising,
      condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiObservationStationImplCopyWith<_$TsunamiObservationStationImpl>
      get copyWith => __$$TsunamiObservationStationImplCopyWithImpl<
          _$TsunamiObservationStationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiObservationStationImplToJson(
      this,
    );
  }
}

abstract class _TsunamiObservationStation implements TsunamiObservationStation {
  const factory _TsunamiObservationStation(
          {required final String code,
          required final String name,
          required final DateTime? firstHeightArrivalTime,
          required final TsunamiObservationStationFirstHeightIntial?
              firstHeightInitial,
          required final DateTime? maxHeightTime,
          required final double? maxHeightValue,
          required final bool? maxHeightIsOver,
          required final bool? maxHeightIsRising,
          required final TsunamiObservationStationCondition? condition}) =
      _$TsunamiObservationStationImpl;

  factory _TsunamiObservationStation.fromJson(Map<String, dynamic> json) =
      _$TsunamiObservationStationImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override

  /// null: ``
  DateTime? get firstHeightArrivalTime;
  @override
  TsunamiObservationStationFirstHeightIntial? get firstHeightInitial;
  @override
  DateTime? get maxHeightTime;
  @override
  double? get maxHeightValue;
  @override
  bool? get maxHeightIsOver;
  @override

  /// 
  bool? get maxHeightIsRising;
  @override
  TsunamiObservationStationCondition? get condition;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiObservationStationImplCopyWith<_$TsunamiObservationStationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

TsunamiEstimation _$TsunamiEstimationFromJson(Map<String, dynamic> json) {
  return _TsunamiEstimation.fromJson(json);
}

/// @nodoc
mixin _$TsunamiEstimation {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  DateTime? get firstHeightTime => throw _privateConstructorUsedError;
  TsunamiEstimationFirstHeightCondition? get firstHeightCondition =>
      throw _privateConstructorUsedError;
  DateTime? get maxHeightTime => throw _privateConstructorUsedError;
  double? get maxHeightValue => throw _privateConstructorUsedError;
  bool? get maxHeightIsOver => throw _privateConstructorUsedError;
  TsunamiMaxHeightCondition? get maxHeightCondition =>
      throw _privateConstructorUsedError; // 
// **
  bool? get isObserving => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TsunamiEstimationCopyWith<TsunamiEstimation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TsunamiEstimationCopyWith<$Res> {
  factory $TsunamiEstimationCopyWith(
          TsunamiEstimation value, $Res Function(TsunamiEstimation) then) =
      _$TsunamiEstimationCopyWithImpl<$Res, TsunamiEstimation>;
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime? firstHeightTime,
      TsunamiEstimationFirstHeightCondition? firstHeightCondition,
      DateTime? maxHeightTime,
      double? maxHeightValue,
      bool? maxHeightIsOver,
      TsunamiMaxHeightCondition? maxHeightCondition,
      bool? isObserving});
}

/// @nodoc
class _$TsunamiEstimationCopyWithImpl<$Res, $Val extends TsunamiEstimation>
    implements $TsunamiEstimationCopyWith<$Res> {
  _$TsunamiEstimationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? firstHeightTime = freezed,
    Object? firstHeightCondition = freezed,
    Object? maxHeightTime = freezed,
    Object? maxHeightValue = freezed,
    Object? maxHeightIsOver = freezed,
    Object? maxHeightCondition = freezed,
    Object? isObserving = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeightTime: freezed == firstHeightTime
          ? _value.firstHeightTime
          : firstHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstHeightCondition: freezed == firstHeightCondition
          ? _value.firstHeightCondition
          : firstHeightCondition // ignore: cast_nullable_to_non_nullable
              as TsunamiEstimationFirstHeightCondition?,
      maxHeightTime: freezed == maxHeightTime
          ? _value.maxHeightTime
          : maxHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      maxHeightValue: freezed == maxHeightValue
          ? _value.maxHeightValue
          : maxHeightValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxHeightIsOver: freezed == maxHeightIsOver
          ? _value.maxHeightIsOver
          : maxHeightIsOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      maxHeightCondition: freezed == maxHeightCondition
          ? _value.maxHeightCondition
          : maxHeightCondition // ignore: cast_nullable_to_non_nullable
              as TsunamiMaxHeightCondition?,
      isObserving: freezed == isObserving
          ? _value.isObserving
          : isObserving // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TsunamiEstimationImplCopyWith<$Res>
    implements $TsunamiEstimationCopyWith<$Res> {
  factory _$$TsunamiEstimationImplCopyWith(_$TsunamiEstimationImpl value,
          $Res Function(_$TsunamiEstimationImpl) then) =
      __$$TsunamiEstimationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      String name,
      DateTime? firstHeightTime,
      TsunamiEstimationFirstHeightCondition? firstHeightCondition,
      DateTime? maxHeightTime,
      double? maxHeightValue,
      bool? maxHeightIsOver,
      TsunamiMaxHeightCondition? maxHeightCondition,
      bool? isObserving});
}

/// @nodoc
class __$$TsunamiEstimationImplCopyWithImpl<$Res>
    extends _$TsunamiEstimationCopyWithImpl<$Res, _$TsunamiEstimationImpl>
    implements _$$TsunamiEstimationImplCopyWith<$Res> {
  __$$TsunamiEstimationImplCopyWithImpl(_$TsunamiEstimationImpl _value,
      $Res Function(_$TsunamiEstimationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
    Object? firstHeightTime = freezed,
    Object? firstHeightCondition = freezed,
    Object? maxHeightTime = freezed,
    Object? maxHeightValue = freezed,
    Object? maxHeightIsOver = freezed,
    Object? maxHeightCondition = freezed,
    Object? isObserving = freezed,
  }) {
    return _then(_$TsunamiEstimationImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      firstHeightTime: freezed == firstHeightTime
          ? _value.firstHeightTime
          : firstHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstHeightCondition: freezed == firstHeightCondition
          ? _value.firstHeightCondition
          : firstHeightCondition // ignore: cast_nullable_to_non_nullable
              as TsunamiEstimationFirstHeightCondition?,
      maxHeightTime: freezed == maxHeightTime
          ? _value.maxHeightTime
          : maxHeightTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      maxHeightValue: freezed == maxHeightValue
          ? _value.maxHeightValue
          : maxHeightValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxHeightIsOver: freezed == maxHeightIsOver
          ? _value.maxHeightIsOver
          : maxHeightIsOver // ignore: cast_nullable_to_non_nullable
              as bool?,
      maxHeightCondition: freezed == maxHeightCondition
          ? _value.maxHeightCondition
          : maxHeightCondition // ignore: cast_nullable_to_non_nullable
              as TsunamiMaxHeightCondition?,
      isObserving: freezed == isObserving
          ? _value.isObserving
          : isObserving // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

@JsonSerializable(fieldRename: FieldRename.none)
class _$TsunamiEstimationImpl implements _TsunamiEstimation {
  const _$TsunamiEstimationImpl(
      {required this.code,
      required this.name,
      required this.firstHeightTime,
      required this.firstHeightCondition,
      required this.maxHeightTime,
      required this.maxHeightValue,
      required this.maxHeightIsOver,
      required this.maxHeightCondition,
      required this.isObserving});

  factory _$TsunamiEstimationImpl.fromJson(Map<String, dynamic> json) =>
      _$$TsunamiEstimationImplFromJson(json);

  @override
  final String code;
  @override
  final String name;
  @override
  final DateTime? firstHeightTime;
  @override
  final TsunamiEstimationFirstHeightCondition? firstHeightCondition;
  @override
  final DateTime? maxHeightTime;
  @override
  final double? maxHeightValue;
  @override
  final bool? maxHeightIsOver;
  @override
  final TsunamiMaxHeightCondition? maxHeightCondition;
// 
// **
  @override
  final bool? isObserving;

  @override
  String toString() {
    return 'TsunamiEstimation(code: $code, name: $name, firstHeightTime: $firstHeightTime, firstHeightCondition: $firstHeightCondition, maxHeightTime: $maxHeightTime, maxHeightValue: $maxHeightValue, maxHeightIsOver: $maxHeightIsOver, maxHeightCondition: $maxHeightCondition, isObserving: $isObserving)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TsunamiEstimationImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.firstHeightTime, firstHeightTime) ||
                other.firstHeightTime == firstHeightTime) &&
            (identical(other.firstHeightCondition, firstHeightCondition) ||
                other.firstHeightCondition == firstHeightCondition) &&
            (identical(other.maxHeightTime, maxHeightTime) ||
                other.maxHeightTime == maxHeightTime) &&
            (identical(other.maxHeightValue, maxHeightValue) ||
                other.maxHeightValue == maxHeightValue) &&
            (identical(other.maxHeightIsOver, maxHeightIsOver) ||
                other.maxHeightIsOver == maxHeightIsOver) &&
            (identical(other.maxHeightCondition, maxHeightCondition) ||
                other.maxHeightCondition == maxHeightCondition) &&
            (identical(other.isObserving, isObserving) ||
                other.isObserving == isObserving));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      code,
      name,
      firstHeightTime,
      firstHeightCondition,
      maxHeightTime,
      maxHeightValue,
      maxHeightIsOver,
      maxHeightCondition,
      isObserving);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TsunamiEstimationImplCopyWith<_$TsunamiEstimationImpl> get copyWith =>
      __$$TsunamiEstimationImplCopyWithImpl<_$TsunamiEstimationImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TsunamiEstimationImplToJson(
      this,
    );
  }
}

abstract class _TsunamiEstimation implements TsunamiEstimation {
  const factory _TsunamiEstimation(
      {required final String code,
      required final String name,
      required final DateTime? firstHeightTime,
      required final TsunamiEstimationFirstHeightCondition?
          firstHeightCondition,
      required final DateTime? maxHeightTime,
      required final double? maxHeightValue,
      required final bool? maxHeightIsOver,
      required final TsunamiMaxHeightCondition? maxHeightCondition,
      required final bool? isObserving}) = _$TsunamiEstimationImpl;

  factory _TsunamiEstimation.fromJson(Map<String, dynamic> json) =
      _$TsunamiEstimationImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override
  DateTime? get firstHeightTime;
  @override
  TsunamiEstimationFirstHeightCondition? get firstHeightCondition;
  @override
  DateTime? get maxHeightTime;
  @override
  double? get maxHeightValue;
  @override
  bool? get maxHeightIsOver;
  @override
  TsunamiMaxHeightCondition? get maxHeightCondition;
  @override // 
// **
  bool? get isObserving;
  @override
  @JsonKey(ignore: true)
  _$$TsunamiEstimationImplCopyWith<_$TsunamiEstimationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PublicBodyVTSE41 _$PublicBodyVTSE41FromJson(Map<String, dynamic> json) {
  return _PublicBodyVTSE41.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE41 {
  PublicBodyVTSE41Tsunami get tsunami => throw _privateConstructorUsedError;
  List<Earthquake> get earthquakes => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  Comment? get comment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE41CopyWith<PublicBodyVTSE41> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE41CopyWith<$Res> {
  factory $PublicBodyVTSE41CopyWith(
          PublicBodyVTSE41 value, $Res Function(PublicBodyVTSE41) then) =
      _$PublicBodyVTSE41CopyWithImpl<$Res, PublicBodyVTSE41>;
  @useResult
  $Res call(
      {PublicBodyVTSE41Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  $PublicBodyVTSE41TsunamiCopyWith<$Res> get tsunami;
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class _$PublicBodyVTSE41CopyWithImpl<$Res, $Val extends PublicBodyVTSE41>
    implements $PublicBodyVTSE41CopyWith<$Res> {
  _$PublicBodyVTSE41CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE41Tsunami,
      earthquakes: null == earthquakes
          ? _value.earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PublicBodyVTSE41TsunamiCopyWith<$Res> get tsunami {
    return $PublicBodyVTSE41TsunamiCopyWith<$Res>(_value.tsunami, (value) {
      return _then(_value.copyWith(tsunami: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CommentCopyWith<$Res>? get comment {
    if (_value.comment == null) {
      return null;
    }

    return $CommentCopyWith<$Res>(_value.comment!, (value) {
      return _then(_value.copyWith(comment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE41ImplCopyWith<$Res>
    implements $PublicBodyVTSE41CopyWith<$Res> {
  factory _$$PublicBodyVTSE41ImplCopyWith(_$PublicBodyVTSE41Impl value,
          $Res Function(_$PublicBodyVTSE41Impl) then) =
      __$$PublicBodyVTSE41ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PublicBodyVTSE41Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  @override
  $PublicBodyVTSE41TsunamiCopyWith<$Res> get tsunami;
  @override
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class __$$PublicBodyVTSE41ImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE41CopyWithImpl<$Res, _$PublicBodyVTSE41Impl>
    implements _$$PublicBodyVTSE41ImplCopyWith<$Res> {
  __$$PublicBodyVTSE41ImplCopyWithImpl(_$PublicBodyVTSE41Impl _value,
      $Res Function(_$PublicBodyVTSE41Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_$PublicBodyVTSE41Impl(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE41Tsunami,
      earthquakes: null == earthquakes
          ? _value._earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE41Impl implements _PublicBodyVTSE41 {
  const _$PublicBodyVTSE41Impl(
      {required this.tsunami,
      required final List<Earthquake> earthquakes,
      required this.text,
      required this.comment})
      : _earthquakes = earthquakes;

  factory _$PublicBodyVTSE41Impl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE41ImplFromJson(json);

  @override
  final PublicBodyVTSE41Tsunami tsunami;
  final List<Earthquake> _earthquakes;
  @override
  List<Earthquake> get earthquakes {
    if (_earthquakes is EqualUnmodifiableListView) return _earthquakes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_earthquakes);
  }

  @override
  final String? text;
  @override
  final Comment? comment;

  @override
  String toString() {
    return 'PublicBodyVTSE41(tsunami: $tsunami, earthquakes: $earthquakes, text: $text, comment: $comment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE41Impl &&
            (identical(other.tsunami, tsunami) || other.tsunami == tsunami) &&
            const DeepCollectionEquality()
                .equals(other._earthquakes, _earthquakes) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tsunami,
      const DeepCollectionEquality().hash(_earthquakes), text, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE41ImplCopyWith<_$PublicBodyVTSE41Impl> get copyWith =>
      __$$PublicBodyVTSE41ImplCopyWithImpl<_$PublicBodyVTSE41Impl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE41ImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE41 implements PublicBodyVTSE41 {
  const factory _PublicBodyVTSE41(
      {required final PublicBodyVTSE41Tsunami tsunami,
      required final List<Earthquake> earthquakes,
      required final String? text,
      required final Comment? comment}) = _$PublicBodyVTSE41Impl;

  factory _PublicBodyVTSE41.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE41Impl.fromJson;

  @override
  PublicBodyVTSE41Tsunami get tsunami;
  @override
  List<Earthquake> get earthquakes;
  @override
  String? get text;
  @override
  Comment? get comment;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE41ImplCopyWith<_$PublicBodyVTSE41Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

PublicBodyVTSE51 _$PublicBodyVTSE51FromJson(Map<String, dynamic> json) {
  return _PublicBodyVTSE51.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE51 {
  PublicBodyVTSE51Tsunami get tsunami => throw _privateConstructorUsedError;
  List<Earthquake> get earthquakes => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  Comment? get comment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE51CopyWith<PublicBodyVTSE51> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE51CopyWith<$Res> {
  factory $PublicBodyVTSE51CopyWith(
          PublicBodyVTSE51 value, $Res Function(PublicBodyVTSE51) then) =
      _$PublicBodyVTSE51CopyWithImpl<$Res, PublicBodyVTSE51>;
  @useResult
  $Res call(
      {PublicBodyVTSE51Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  $PublicBodyVTSE51TsunamiCopyWith<$Res> get tsunami;
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class _$PublicBodyVTSE51CopyWithImpl<$Res, $Val extends PublicBodyVTSE51>
    implements $PublicBodyVTSE51CopyWith<$Res> {
  _$PublicBodyVTSE51CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE51Tsunami,
      earthquakes: null == earthquakes
          ? _value.earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PublicBodyVTSE51TsunamiCopyWith<$Res> get tsunami {
    return $PublicBodyVTSE51TsunamiCopyWith<$Res>(_value.tsunami, (value) {
      return _then(_value.copyWith(tsunami: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CommentCopyWith<$Res>? get comment {
    if (_value.comment == null) {
      return null;
    }

    return $CommentCopyWith<$Res>(_value.comment!, (value) {
      return _then(_value.copyWith(comment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE51ImplCopyWith<$Res>
    implements $PublicBodyVTSE51CopyWith<$Res> {
  factory _$$PublicBodyVTSE51ImplCopyWith(_$PublicBodyVTSE51Impl value,
          $Res Function(_$PublicBodyVTSE51Impl) then) =
      __$$PublicBodyVTSE51ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PublicBodyVTSE51Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  @override
  $PublicBodyVTSE51TsunamiCopyWith<$Res> get tsunami;
  @override
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class __$$PublicBodyVTSE51ImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE51CopyWithImpl<$Res, _$PublicBodyVTSE51Impl>
    implements _$$PublicBodyVTSE51ImplCopyWith<$Res> {
  __$$PublicBodyVTSE51ImplCopyWithImpl(_$PublicBodyVTSE51Impl _value,
      $Res Function(_$PublicBodyVTSE51Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_$PublicBodyVTSE51Impl(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE51Tsunami,
      earthquakes: null == earthquakes
          ? _value._earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE51Impl implements _PublicBodyVTSE51 {
  const _$PublicBodyVTSE51Impl(
      {required this.tsunami,
      required final List<Earthquake> earthquakes,
      required this.text,
      required this.comment})
      : _earthquakes = earthquakes;

  factory _$PublicBodyVTSE51Impl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE51ImplFromJson(json);

  @override
  final PublicBodyVTSE51Tsunami tsunami;
  final List<Earthquake> _earthquakes;
  @override
  List<Earthquake> get earthquakes {
    if (_earthquakes is EqualUnmodifiableListView) return _earthquakes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_earthquakes);
  }

  @override
  final String? text;
  @override
  final Comment? comment;

  @override
  String toString() {
    return 'PublicBodyVTSE51(tsunami: $tsunami, earthquakes: $earthquakes, text: $text, comment: $comment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE51Impl &&
            (identical(other.tsunami, tsunami) || other.tsunami == tsunami) &&
            const DeepCollectionEquality()
                .equals(other._earthquakes, _earthquakes) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tsunami,
      const DeepCollectionEquality().hash(_earthquakes), text, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE51ImplCopyWith<_$PublicBodyVTSE51Impl> get copyWith =>
      __$$PublicBodyVTSE51ImplCopyWithImpl<_$PublicBodyVTSE51Impl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE51ImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE51 implements PublicBodyVTSE51 {
  const factory _PublicBodyVTSE51(
      {required final PublicBodyVTSE51Tsunami tsunami,
      required final List<Earthquake> earthquakes,
      required final String? text,
      required final Comment? comment}) = _$PublicBodyVTSE51Impl;

  factory _PublicBodyVTSE51.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE51Impl.fromJson;

  @override
  PublicBodyVTSE51Tsunami get tsunami;
  @override
  List<Earthquake> get earthquakes;
  @override
  String? get text;
  @override
  Comment? get comment;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE51ImplCopyWith<_$PublicBodyVTSE51Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

PublicBodyVTSE52 _$PublicBodyVTSE52FromJson(Map<String, dynamic> json) {
  return _PublicBodyVTSE52.fromJson(json);
}

/// @nodoc
mixin _$PublicBodyVTSE52 {
  PublicBodyVTSE52Tsunami get tsunami => throw _privateConstructorUsedError;
  List<Earthquake> get earthquakes => throw _privateConstructorUsedError;
  String? get text => throw _privateConstructorUsedError;
  Comment? get comment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PublicBodyVTSE52CopyWith<PublicBodyVTSE52> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublicBodyVTSE52CopyWith<$Res> {
  factory $PublicBodyVTSE52CopyWith(
          PublicBodyVTSE52 value, $Res Function(PublicBodyVTSE52) then) =
      _$PublicBodyVTSE52CopyWithImpl<$Res, PublicBodyVTSE52>;
  @useResult
  $Res call(
      {PublicBodyVTSE52Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  $PublicBodyVTSE52TsunamiCopyWith<$Res> get tsunami;
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class _$PublicBodyVTSE52CopyWithImpl<$Res, $Val extends PublicBodyVTSE52>
    implements $PublicBodyVTSE52CopyWith<$Res> {
  _$PublicBodyVTSE52CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE52Tsunami,
      earthquakes: null == earthquakes
          ? _value.earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PublicBodyVTSE52TsunamiCopyWith<$Res> get tsunami {
    return $PublicBodyVTSE52TsunamiCopyWith<$Res>(_value.tsunami, (value) {
      return _then(_value.copyWith(tsunami: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CommentCopyWith<$Res>? get comment {
    if (_value.comment == null) {
      return null;
    }

    return $CommentCopyWith<$Res>(_value.comment!, (value) {
      return _then(_value.copyWith(comment: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PublicBodyVTSE52ImplCopyWith<$Res>
    implements $PublicBodyVTSE52CopyWith<$Res> {
  factory _$$PublicBodyVTSE52ImplCopyWith(_$PublicBodyVTSE52Impl value,
          $Res Function(_$PublicBodyVTSE52Impl) then) =
      __$$PublicBodyVTSE52ImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {PublicBodyVTSE52Tsunami tsunami,
      List<Earthquake> earthquakes,
      String? text,
      Comment? comment});

  @override
  $PublicBodyVTSE52TsunamiCopyWith<$Res> get tsunami;
  @override
  $CommentCopyWith<$Res>? get comment;
}

/// @nodoc
class __$$PublicBodyVTSE52ImplCopyWithImpl<$Res>
    extends _$PublicBodyVTSE52CopyWithImpl<$Res, _$PublicBodyVTSE52Impl>
    implements _$$PublicBodyVTSE52ImplCopyWith<$Res> {
  __$$PublicBodyVTSE52ImplCopyWithImpl(_$PublicBodyVTSE52Impl _value,
      $Res Function(_$PublicBodyVTSE52Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tsunami = null,
    Object? earthquakes = null,
    Object? text = freezed,
    Object? comment = freezed,
  }) {
    return _then(_$PublicBodyVTSE52Impl(
      tsunami: null == tsunami
          ? _value.tsunami
          : tsunami // ignore: cast_nullable_to_non_nullable
              as PublicBodyVTSE52Tsunami,
      earthquakes: null == earthquakes
          ? _value._earthquakes
          : earthquakes // ignore: cast_nullable_to_non_nullable
              as List<Earthquake>,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as Comment?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PublicBodyVTSE52Impl implements _PublicBodyVTSE52 {
  const _$PublicBodyVTSE52Impl(
      {required this.tsunami,
      required final List<Earthquake> earthquakes,
      required this.text,
      required this.comment})
      : _earthquakes = earthquakes;

  factory _$PublicBodyVTSE52Impl.fromJson(Map<String, dynamic> json) =>
      _$$PublicBodyVTSE52ImplFromJson(json);

  @override
  final PublicBodyVTSE52Tsunami tsunami;
  final List<Earthquake> _earthquakes;
  @override
  List<Earthquake> get earthquakes {
    if (_earthquakes is EqualUnmodifiableListView) return _earthquakes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_earthquakes);
  }

  @override
  final String? text;
  @override
  final Comment? comment;

  @override
  String toString() {
    return 'PublicBodyVTSE52(tsunami: $tsunami, earthquakes: $earthquakes, text: $text, comment: $comment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PublicBodyVTSE52Impl &&
            (identical(other.tsunami, tsunami) || other.tsunami == tsunami) &&
            const DeepCollectionEquality()
                .equals(other._earthquakes, _earthquakes) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, tsunami,
      const DeepCollectionEquality().hash(_earthquakes), text, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PublicBodyVTSE52ImplCopyWith<_$PublicBodyVTSE52Impl> get copyWith =>
      __$$PublicBodyVTSE52ImplCopyWithImpl<_$PublicBodyVTSE52Impl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PublicBodyVTSE52ImplToJson(
      this,
    );
  }
}

abstract class _PublicBodyVTSE52 implements PublicBodyVTSE52 {
  const factory _PublicBodyVTSE52(
      {required final PublicBodyVTSE52Tsunami tsunami,
      required final List<Earthquake> earthquakes,
      required final String? text,
      required final Comment? comment}) = _$PublicBodyVTSE52Impl;

  factory _PublicBodyVTSE52.fromJson(Map<String, dynamic> json) =
      _$PublicBodyVTSE52Impl.fromJson;

  @override
  PublicBodyVTSE52Tsunami get tsunami;
  @override
  List<Earthquake> get earthquakes;
  @override
  String? get text;
  @override
  Comment? get comment;
  @override
  @JsonKey(ignore: true)
  _$$PublicBodyVTSE52ImplCopyWith<_$PublicBodyVTSE52Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

Earthquake _$EarthquakeFromJson(Map<String, dynamic> json) {
  return _Earthquake.fromJson(json);
}

/// @nodoc
mixin _$Earthquake {
  DateTime get originTime => throw _privateConstructorUsedError;
  DateTime get arrivalTime => throw _privateConstructorUsedError;
  EarthquakeHypocenter get hypocenter => throw _privateConstructorUsedError;
  EarthquakeMagnitude get magnitude => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EarthquakeCopyWith<Earthquake> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EarthquakeCopyWith<$Res> {
  factory $EarthquakeCopyWith(
          Earthquake value, $Res Function(Earthquake) then) =
      _$EarthquakeCopyWithImpl<$Res, Earthquake>;
  @useResult
  $Res call(
      {DateTime originTime,
      DateTime arrivalTime,
      EarthquakeHypocenter hypocenter,
      EarthquakeMagnitude magnitude});

  $EarthquakeHypocenterCopyWith<$Res> get hypocenter;
  $EarthquakeMagnitudeCopyWith<$Res> get magnitude;
}

/// @nodoc
class _$EarthquakeCopyWithImpl<$Res, $Val extends Earthquake>
    implements $EarthquakeCopyWith<$Res> {
  _$EarthquakeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? originTime = null,
    Object? arrivalTime = null,
    Object? hypocenter = null,
    Object? magnitude = null,
  }) {
    return _then(_value.copyWith(
      originTime: null == originTime
          ? _value.originTime
          : originTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      arrivalTime: null == arrivalTime
          ? _value.arrivalTime
          : arrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      hypocenter: null == hypocenter
          ? _value.hypocenter
          : hypocenter // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenter,
      magnitude: null == magnitude
          ? _value.magnitude
          : magnitude // ignore: cast_nullable_to_non_nullable
              as EarthquakeMagnitude,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EarthquakeHypocenterCopyWith<$Res> get hypocenter {
    return $EarthquakeHypocenterCopyWith<$Res>(_value.hypocenter, (value) {
      return _then(_value.copyWith(hypocenter: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EarthquakeMagnitudeCopyWith<$Res> get magnitude {
    return $EarthquakeMagnitudeCopyWith<$Res>(_value.magnitude, (value) {
      return _then(_value.copyWith(magnitude: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EarthquakeImplCopyWith<$Res>
    implements $EarthquakeCopyWith<$Res> {
  factory _$$EarthquakeImplCopyWith(
          _$EarthquakeImpl value, $Res Function(_$EarthquakeImpl) then) =
      __$$EarthquakeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {DateTime originTime,
      DateTime arrivalTime,
      EarthquakeHypocenter hypocenter,
      EarthquakeMagnitude magnitude});

  @override
  $EarthquakeHypocenterCopyWith<$Res> get hypocenter;
  @override
  $EarthquakeMagnitudeCopyWith<$Res> get magnitude;
}

/// @nodoc
class __$$EarthquakeImplCopyWithImpl<$Res>
    extends _$EarthquakeCopyWithImpl<$Res, _$EarthquakeImpl>
    implements _$$EarthquakeImplCopyWith<$Res> {
  __$$EarthquakeImplCopyWithImpl(
      _$EarthquakeImpl _value, $Res Function(_$EarthquakeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? originTime = null,
    Object? arrivalTime = null,
    Object? hypocenter = null,
    Object? magnitude = null,
  }) {
    return _then(_$EarthquakeImpl(
      originTime: null == originTime
          ? _value.originTime
          : originTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      arrivalTime: null == arrivalTime
          ? _value.arrivalTime
          : arrivalTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      hypocenter: null == hypocenter
          ? _value.hypocenter
          : hypocenter // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenter,
      magnitude: null == magnitude
          ? _value.magnitude
          : magnitude // ignore: cast_nullable_to_non_nullable
              as EarthquakeMagnitude,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EarthquakeImpl implements _Earthquake {
  const _$EarthquakeImpl(
      {required this.originTime,
      required this.arrivalTime,
      required this.hypocenter,
      required this.magnitude});

  factory _$EarthquakeImpl.fromJson(Map<String, dynamic> json) =>
      _$$EarthquakeImplFromJson(json);

  @override
  final DateTime originTime;
  @override
  final DateTime arrivalTime;
  @override
  final EarthquakeHypocenter hypocenter;
  @override
  final EarthquakeMagnitude magnitude;

  @override
  String toString() {
    return 'Earthquake(originTime: $originTime, arrivalTime: $arrivalTime, hypocenter: $hypocenter, magnitude: $magnitude)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EarthquakeImpl &&
            (identical(other.originTime, originTime) ||
                other.originTime == originTime) &&
            (identical(other.arrivalTime, arrivalTime) ||
                other.arrivalTime == arrivalTime) &&
            (identical(other.hypocenter, hypocenter) ||
                other.hypocenter == hypocenter) &&
            (identical(other.magnitude, magnitude) ||
                other.magnitude == magnitude));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, originTime, arrivalTime, hypocenter, magnitude);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EarthquakeImplCopyWith<_$EarthquakeImpl> get copyWith =>
      __$$EarthquakeImplCopyWithImpl<_$EarthquakeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EarthquakeImplToJson(
      this,
    );
  }
}

abstract class _Earthquake implements Earthquake {
  const factory _Earthquake(
      {required final DateTime originTime,
      required final DateTime arrivalTime,
      required final EarthquakeHypocenter hypocenter,
      required final EarthquakeMagnitude magnitude}) = _$EarthquakeImpl;

  factory _Earthquake.fromJson(Map<String, dynamic> json) =
      _$EarthquakeImpl.fromJson;

  @override
  DateTime get originTime;
  @override
  DateTime get arrivalTime;
  @override
  EarthquakeHypocenter get hypocenter;
  @override
  EarthquakeMagnitude get magnitude;
  @override
  @JsonKey(ignore: true)
  _$$EarthquakeImplCopyWith<_$EarthquakeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

EarthquakeHypocenter _$EarthquakeHypocenterFromJson(Map<String, dynamic> json) {
  return _EarthquakeHypocenter.fromJson(json);
}

/// @nodoc
mixin _$EarthquakeHypocenter {
  String get name => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;
  int? get depth => throw _privateConstructorUsedError;
  EarthquakeHypocenterDetailed? get detailed =>
      throw _privateConstructorUsedError;
  EarthquakeHypocenterCoordinate? get coordinate =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EarthquakeHypocenterCopyWith<EarthquakeHypocenter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EarthquakeHypocenterCopyWith<$Res> {
  factory $EarthquakeHypocenterCopyWith(EarthquakeHypocenter value,
          $Res Function(EarthquakeHypocenter) then) =
      _$EarthquakeHypocenterCopyWithImpl<$Res, EarthquakeHypocenter>;
  @useResult
  $Res call(
      {String name,
      String code,
      int? depth,
      EarthquakeHypocenterDetailed? detailed,
      EarthquakeHypocenterCoordinate? coordinate});

  $EarthquakeHypocenterDetailedCopyWith<$Res>? get detailed;
  $EarthquakeHypocenterCoordinateCopyWith<$Res>? get coordinate;
}

/// @nodoc
class _$EarthquakeHypocenterCopyWithImpl<$Res,
        $Val extends EarthquakeHypocenter>
    implements $EarthquakeHypocenterCopyWith<$Res> {
  _$EarthquakeHypocenterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? code = null,
    Object? depth = freezed,
    Object? detailed = freezed,
    Object? coordinate = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      depth: freezed == depth
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as int?,
      detailed: freezed == detailed
          ? _value.detailed
          : detailed // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenterDetailed?,
      coordinate: freezed == coordinate
          ? _value.coordinate
          : coordinate // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenterCoordinate?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $EarthquakeHypocenterDetailedCopyWith<$Res>? get detailed {
    if (_value.detailed == null) {
      return null;
    }

    return $EarthquakeHypocenterDetailedCopyWith<$Res>(_value.detailed!,
        (value) {
      return _then(_value.copyWith(detailed: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EarthquakeHypocenterCoordinateCopyWith<$Res>? get coordinate {
    if (_value.coordinate == null) {
      return null;
    }

    return $EarthquakeHypocenterCoordinateCopyWith<$Res>(_value.coordinate!,
        (value) {
      return _then(_value.copyWith(coordinate: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EarthquakeHypocenterImplCopyWith<$Res>
    implements $EarthquakeHypocenterCopyWith<$Res> {
  factory _$$EarthquakeHypocenterImplCopyWith(_$EarthquakeHypocenterImpl value,
          $Res Function(_$EarthquakeHypocenterImpl) then) =
      __$$EarthquakeHypocenterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String code,
      int? depth,
      EarthquakeHypocenterDetailed? detailed,
      EarthquakeHypocenterCoordinate? coordinate});

  @override
  $EarthquakeHypocenterDetailedCopyWith<$Res>? get detailed;
  @override
  $EarthquakeHypocenterCoordinateCopyWith<$Res>? get coordinate;
}

/// @nodoc
class __$$EarthquakeHypocenterImplCopyWithImpl<$Res>
    extends _$EarthquakeHypocenterCopyWithImpl<$Res, _$EarthquakeHypocenterImpl>
    implements _$$EarthquakeHypocenterImplCopyWith<$Res> {
  __$$EarthquakeHypocenterImplCopyWithImpl(_$EarthquakeHypocenterImpl _value,
      $Res Function(_$EarthquakeHypocenterImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? code = null,
    Object? depth = freezed,
    Object? detailed = freezed,
    Object? coordinate = freezed,
  }) {
    return _then(_$EarthquakeHypocenterImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      depth: freezed == depth
          ? _value.depth
          : depth // ignore: cast_nullable_to_non_nullable
              as int?,
      detailed: freezed == detailed
          ? _value.detailed
          : detailed // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenterDetailed?,
      coordinate: freezed == coordinate
          ? _value.coordinate
          : coordinate // ignore: cast_nullable_to_non_nullable
              as EarthquakeHypocenterCoordinate?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EarthquakeHypocenterImpl implements _EarthquakeHypocenter {
  const _$EarthquakeHypocenterImpl(
      {required this.name,
      required this.code,
      required this.depth,
      required this.detailed,
      required this.coordinate});

  factory _$EarthquakeHypocenterImpl.fromJson(Map<String, dynamic> json) =>
      _$$EarthquakeHypocenterImplFromJson(json);

  @override
  final String name;
  @override
  final String code;
  @override
  final int? depth;
  @override
  final EarthquakeHypocenterDetailed? detailed;
  @override
  final EarthquakeHypocenterCoordinate? coordinate;

  @override
  String toString() {
    return 'EarthquakeHypocenter(name: $name, code: $code, depth: $depth, detailed: $detailed, coordinate: $coordinate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EarthquakeHypocenterImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.depth, depth) || other.depth == depth) &&
            (identical(other.detailed, detailed) ||
                other.detailed == detailed) &&
            (identical(other.coordinate, coordinate) ||
                other.coordinate == coordinate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, name, code, depth, detailed, coordinate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EarthquakeHypocenterImplCopyWith<_$EarthquakeHypocenterImpl>
      get copyWith =>
          __$$EarthquakeHypocenterImplCopyWithImpl<_$EarthquakeHypocenterImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EarthquakeHypocenterImplToJson(
      this,
    );
  }
}

abstract class _EarthquakeHypocenter implements EarthquakeHypocenter {
  const factory _EarthquakeHypocenter(
          {required final String name,
          required final String code,
          required final int? depth,
          required final EarthquakeHypocenterDetailed? detailed,
          required final EarthquakeHypocenterCoordinate? coordinate}) =
      _$EarthquakeHypocenterImpl;

  factory _EarthquakeHypocenter.fromJson(Map<String, dynamic> json) =
      _$EarthquakeHypocenterImpl.fromJson;

  @override
  String get name;
  @override
  String get code;
  @override
  int? get depth;
  @override
  EarthquakeHypocenterDetailed? get detailed;
  @override
  EarthquakeHypocenterCoordinate? get coordinate;
  @override
  @JsonKey(ignore: true)
  _$$EarthquakeHypocenterImplCopyWith<_$EarthquakeHypocenterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EarthquakeHypocenterDetailed _$EarthquakeHypocenterDetailedFromJson(
    Map<String, dynamic> json) {
  return _EarthquakeHypocenterDetailed.fromJson(json);
}

/// @nodoc
mixin _$EarthquakeHypocenterDetailed {
  String get code => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EarthquakeHypocenterDetailedCopyWith<EarthquakeHypocenterDetailed>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EarthquakeHypocenterDetailedCopyWith<$Res> {
  factory $EarthquakeHypocenterDetailedCopyWith(
          EarthquakeHypocenterDetailed value,
          $Res Function(EarthquakeHypocenterDetailed) then) =
      _$EarthquakeHypocenterDetailedCopyWithImpl<$Res,
          EarthquakeHypocenterDetailed>;
  @useResult
  $Res call({String code, String name});
}

/// @nodoc
class _$EarthquakeHypocenterDetailedCopyWithImpl<$Res,
        $Val extends EarthquakeHypocenterDetailed>
    implements $EarthquakeHypocenterDetailedCopyWith<$Res> {
  _$EarthquakeHypocenterDetailedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EarthquakeHypocenterDetailedImplCopyWith<$Res>
    implements $EarthquakeHypocenterDetailedCopyWith<$Res> {
  factory _$$EarthquakeHypocenterDetailedImplCopyWith(
          _$EarthquakeHypocenterDetailedImpl value,
          $Res Function(_$EarthquakeHypocenterDetailedImpl) then) =
      __$$EarthquakeHypocenterDetailedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String code, String name});
}

/// @nodoc
class __$$EarthquakeHypocenterDetailedImplCopyWithImpl<$Res>
    extends _$EarthquakeHypocenterDetailedCopyWithImpl<$Res,
        _$EarthquakeHypocenterDetailedImpl>
    implements _$$EarthquakeHypocenterDetailedImplCopyWith<$Res> {
  __$$EarthquakeHypocenterDetailedImplCopyWithImpl(
      _$EarthquakeHypocenterDetailedImpl _value,
      $Res Function(_$EarthquakeHypocenterDetailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? name = null,
  }) {
    return _then(_$EarthquakeHypocenterDetailedImpl(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EarthquakeHypocenterDetailedImpl
    implements _EarthquakeHypocenterDetailed {
  const _$EarthquakeHypocenterDetailedImpl(
      {required this.code, required this.name});

  factory _$EarthquakeHypocenterDetailedImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EarthquakeHypocenterDetailedImplFromJson(json);

  @override
  final String code;
  @override
  final String name;

  @override
  String toString() {
    return 'EarthquakeHypocenterDetailed(code: $code, name: $name)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EarthquakeHypocenterDetailedImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EarthquakeHypocenterDetailedImplCopyWith<
          _$EarthquakeHypocenterDetailedImpl>
      get copyWith => __$$EarthquakeHypocenterDetailedImplCopyWithImpl<
          _$EarthquakeHypocenterDetailedImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EarthquakeHypocenterDetailedImplToJson(
      this,
    );
  }
}

abstract class _EarthquakeHypocenterDetailed
    implements EarthquakeHypocenterDetailed {
  const factory _EarthquakeHypocenterDetailed(
      {required final String code,
      required final String name}) = _$EarthquakeHypocenterDetailedImpl;

  factory _EarthquakeHypocenterDetailed.fromJson(Map<String, dynamic> json) =
      _$EarthquakeHypocenterDetailedImpl.fromJson;

  @override
  String get code;
  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$EarthquakeHypocenterDetailedImplCopyWith<
          _$EarthquakeHypocenterDetailedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EarthquakeHypocenterCoordinate _$EarthquakeHypocenterCoordinateFromJson(
    Map<String, dynamic> json) {
  return _EarthquakeHypocenterCoordinate.fromJson(json);
}

/// @nodoc
mixin _$EarthquakeHypocenterCoordinate {
  double get lat => throw _privateConstructorUsedError;
  double get lon => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EarthquakeHypocenterCoordinateCopyWith<EarthquakeHypocenterCoordinate>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EarthquakeHypocenterCoordinateCopyWith<$Res> {
  factory $EarthquakeHypocenterCoordinateCopyWith(
          EarthquakeHypocenterCoordinate value,
          $Res Function(EarthquakeHypocenterCoordinate) then) =
      _$EarthquakeHypocenterCoordinateCopyWithImpl<$Res,
          EarthquakeHypocenterCoordinate>;
  @useResult
  $Res call({double lat, double lon});
}

/// @nodoc
class _$EarthquakeHypocenterCoordinateCopyWithImpl<$Res,
        $Val extends EarthquakeHypocenterCoordinate>
    implements $EarthquakeHypocenterCoordinateCopyWith<$Res> {
  _$EarthquakeHypocenterCoordinateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lat = null,
    Object? lon = null,
  }) {
    return _then(_value.copyWith(
      lat: null == lat
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as double,
      lon: null == lon
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EarthquakeHypocenterCoordinateImplCopyWith<$Res>
    implements $EarthquakeHypocenterCoordinateCopyWith<$Res> {
  factory _$$EarthquakeHypocenterCoordinateImplCopyWith(
          _$EarthquakeHypocenterCoordinateImpl value,
          $Res Function(_$EarthquakeHypocenterCoordinateImpl) then) =
      __$$EarthquakeHypocenterCoordinateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double lat, double lon});
}

/// @nodoc
class __$$EarthquakeHypocenterCoordinateImplCopyWithImpl<$Res>
    extends _$EarthquakeHypocenterCoordinateCopyWithImpl<$Res,
        _$EarthquakeHypocenterCoordinateImpl>
    implements _$$EarthquakeHypocenterCoordinateImplCopyWith<$Res> {
  __$$EarthquakeHypocenterCoordinateImplCopyWithImpl(
      _$EarthquakeHypocenterCoordinateImpl _value,
      $Res Function(_$EarthquakeHypocenterCoordinateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lat = null,
    Object? lon = null,
  }) {
    return _then(_$EarthquakeHypocenterCoordinateImpl(
      lat: null == lat
          ? _value.lat
          : lat // ignore: cast_nullable_to_non_nullable
              as double,
      lon: null == lon
          ? _value.lon
          : lon // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EarthquakeHypocenterCoordinateImpl
    implements _EarthquakeHypocenterCoordinate {
  const _$EarthquakeHypocenterCoordinateImpl(
      {required this.lat, required this.lon});

  factory _$EarthquakeHypocenterCoordinateImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EarthquakeHypocenterCoordinateImplFromJson(json);

  @override
  final double lat;
  @override
  final double lon;

  @override
  String toString() {
    return 'EarthquakeHypocenterCoordinate(lat: $lat, lon: $lon)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EarthquakeHypocenterCoordinateImpl &&
            (identical(other.lat, lat) || other.lat == lat) &&
            (identical(other.lon, lon) || other.lon == lon));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, lat, lon);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EarthquakeHypocenterCoordinateImplCopyWith<
          _$EarthquakeHypocenterCoordinateImpl>
      get copyWith => __$$EarthquakeHypocenterCoordinateImplCopyWithImpl<
          _$EarthquakeHypocenterCoordinateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EarthquakeHypocenterCoordinateImplToJson(
      this,
    );
  }
}

abstract class _EarthquakeHypocenterCoordinate
    implements EarthquakeHypocenterCoordinate {
  const factory _EarthquakeHypocenterCoordinate(
      {required final double lat,
      required final double lon}) = _$EarthquakeHypocenterCoordinateImpl;

  factory _EarthquakeHypocenterCoordinate.fromJson(Map<String, dynamic> json) =
      _$EarthquakeHypocenterCoordinateImpl.fromJson;

  @override
  double get lat;
  @override
  double get lon;
  @override
  @JsonKey(ignore: true)
  _$$EarthquakeHypocenterCoordinateImplCopyWith<
          _$EarthquakeHypocenterCoordinateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EarthquakeMagnitude _$EarthquakeMagnitudeFromJson(Map<String, dynamic> json) {
  return _EarthquakeMagnitude.fromJson(json);
}

/// @nodoc
mixin _$EarthquakeMagnitude {
  double? get value => throw _privateConstructorUsedError;
  EarthquakeMagnitudeCondition? get condition =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EarthquakeMagnitudeCopyWith<EarthquakeMagnitude> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EarthquakeMagnitudeCopyWith<$Res> {
  factory $EarthquakeMagnitudeCopyWith(
          EarthquakeMagnitude value, $Res Function(EarthquakeMagnitude) then) =
      _$EarthquakeMagnitudeCopyWithImpl<$Res, EarthquakeMagnitude>;
  @useResult
  $Res call({double? value, EarthquakeMagnitudeCondition? condition});
}

/// @nodoc
class _$EarthquakeMagnitudeCopyWithImpl<$Res, $Val extends EarthquakeMagnitude>
    implements $EarthquakeMagnitudeCopyWith<$Res> {
  _$EarthquakeMagnitudeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? condition = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as EarthquakeMagnitudeCondition?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EarthquakeMagnitudeImplCopyWith<$Res>
    implements $EarthquakeMagnitudeCopyWith<$Res> {
  factory _$$EarthquakeMagnitudeImplCopyWith(_$EarthquakeMagnitudeImpl value,
          $Res Function(_$EarthquakeMagnitudeImpl) then) =
      __$$EarthquakeMagnitudeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double? value, EarthquakeMagnitudeCondition? condition});
}

/// @nodoc
class __$$EarthquakeMagnitudeImplCopyWithImpl<$Res>
    extends _$EarthquakeMagnitudeCopyWithImpl<$Res, _$EarthquakeMagnitudeImpl>
    implements _$$EarthquakeMagnitudeImplCopyWith<$Res> {
  __$$EarthquakeMagnitudeImplCopyWithImpl(_$EarthquakeMagnitudeImpl _value,
      $Res Function(_$EarthquakeMagnitudeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? condition = freezed,
  }) {
    return _then(_$EarthquakeMagnitudeImpl(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double?,
      condition: freezed == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as EarthquakeMagnitudeCondition?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EarthquakeMagnitudeImpl implements _EarthquakeMagnitude {
  const _$EarthquakeMagnitudeImpl(
      {required this.value, required this.condition});

  factory _$EarthquakeMagnitudeImpl.fromJson(Map<String, dynamic> json) =>
      _$$EarthquakeMagnitudeImplFromJson(json);

  @override
  final double? value;
  @override
  final EarthquakeMagnitudeCondition? condition;

  @override
  String toString() {
    return 'EarthquakeMagnitude(value: $value, condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EarthquakeMagnitudeImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value, condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EarthquakeMagnitudeImplCopyWith<_$EarthquakeMagnitudeImpl> get copyWith =>
      __$$EarthquakeMagnitudeImplCopyWithImpl<_$EarthquakeMagnitudeImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EarthquakeMagnitudeImplToJson(
      this,
    );
  }
}

abstract class _EarthquakeMagnitude implements EarthquakeMagnitude {
  const factory _EarthquakeMagnitude(
          {required final double? value,
          required final EarthquakeMagnitudeCondition? condition}) =
      _$EarthquakeMagnitudeImpl;

  factory _EarthquakeMagnitude.fromJson(Map<String, dynamic> json) =
      _$EarthquakeMagnitudeImpl.fromJson;

  @override
  double? get value;
  @override
  EarthquakeMagnitudeCondition? get condition;
  @override
  @JsonKey(ignore: true)
  _$$EarthquakeMagnitudeImplCopyWith<_$EarthquakeMagnitudeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
